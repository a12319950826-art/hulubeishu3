<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anki 学习工具</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            /* 防止页面漂移 */
            overflow-x: hidden;
            position: relative;
            width: 100%;
            max-width: 100vw;
        }
        .container {
            max-width: 900px; margin: 0 auto; background: white;
            border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            /* 确保容器居中且不超出屏幕 */
            position: relative;
            width: 100%;
            box-sizing: border-box;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 30px; text-align: center;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .content { padding: 30px; }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; border: none; padding: 15px 30px;
            border-radius: 10px; cursor: pointer; font-size: 1.1em;
            margin: 10px 5px; transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .btn:active { transform: translateY(0); }
        .btn-secondary { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .btn-success { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .btn-warning { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }
        .back-btn { background: #6c757d; margin-bottom: 20px; }
        input[type="file"] { display: none; }
        .file-upload-label {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 15px 30px; border-radius: 10px;
            cursor: pointer; display: inline-block; font-size: 1.1em;
            margin: 10px 5px; transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }
        .file-upload-label:hover { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .main-menu { text-align: center; }
        .deck-list { margin-top: 20px; }
        .deck-item {
            background: #f8f9fa; padding: 20px; margin: 10px 0;
            border-radius: 10px; display: flex; justify-content: space-between;
            align-items: center; border-left: 5px solid #667eea;
            flex-wrap: wrap; gap: 10px;
        }
        .deck-info { flex: 1; min-width: 200px; }
        .deck-name { font-size: 1.3em; font-weight: bold; margin-bottom: 5px; color: #333; }
        .deck-stats { color: #666; font-size: 0.9em; }
        .card-view { display: none; }
        .card-list-view { display: none; }
        .card-list-container {
            background: #f8f9fa; border-radius: 15px; padding: 20px;
            margin: 20px 0;
        }
        .card-list-item {
            background: white; padding: 15px; margin: 10px 0;
            border-radius: 10px; cursor: pointer;
            border-left: 4px solid #667eea;
            transition: all 0.3s;
        }
        .card-list-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .card-list-item-title {
            font-weight: bold; margin-bottom: 5px;
            font-size: 1.1em;
        }
        .card-list-item-preview {
            color: #666; font-size: 0.9em;
            overflow: hidden; text-overflow: ellipsis;
            white-space: nowrap;
        }
        .card-list-item-stats {
            margin-top: 5px; color: #999; font-size: 0.85em;
        }
        .card-container {
            background: #f8f9fa; border-radius: 15px; padding: 30px;
            margin: 20px 0; min-height: 300px; position: relative;
            border: 3px solid #667eea;
        }
        .card-content {
            font-size: 1.2em; line-height: 1.8;
            user-select: text; -webkit-user-select: text;
            /* 允许正常文本选择 */
            /* 防止选择时页面漂移 */
            overflow-wrap: break-word;
            word-wrap: break-word;
            max-width: 100%;
        }
        /* 遮挡区域允许选择（用于重新选择遮挡）- 仅在PC端 */
        @media (hover: hover) and (pointer: fine) {
            .card-content .masked {
                user-select: text;
                -webkit-user-select: text;
            }
        }
        /* 编辑模式下允许文本选择和复制 */
        .edit-area {
            user-select: text !important;
            -webkit-user-select: text !important;
            -webkit-touch-callout: default !important;
        }
        .card-content img {
            max-width: 100%; height: auto;
            border-radius: 10px; margin: 10px 0;
        }
        .masked {
            background: #667eea; color: transparent;
            border-radius: 2px; padding: 0 1px;
            cursor: pointer; display: inline;
            transition: all 0.3s;
            white-space: pre-wrap;
            margin: 0; /* 确保没有外边距 */
            vertical-align: baseline; /* 与文字基线对齐 */
            line-height: inherit; /* 继承行高，保持与文字一致 */
            /* 触摸设备优化 - 阻止文本选择 */
            -webkit-touch-callout: none; /* 禁用长按菜单 */
            touch-action: manipulation; /* 优化触摸响应 */
            user-select: none; /* 默认不允许选择 */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        /* 移动端进一步减少空格 */
        @media (max-width: 768px) {
            .masked {
                padding: 0; /* 移动端完全移除内边距 */
                border-radius: 1px; /* 更小的圆角 */
                letter-spacing: 0; /* 确保没有额外的字符间距 */
            }
        }
        /* 只在 PC 端允许文本选择（用于重新选择遮挡） */
        @media (hover: hover) and (pointer: fine) {
            .masked {
                user-select: text;
                -webkit-user-select: text;
            }
        }
        .masked:hover { background: #764ba2; }
        .masked.revealed { background: transparent; color: inherit; }
        .card-actions {
            display: flex; justify-content: center;
            gap: 10px; margin-top: 20px; flex-wrap: wrap;
        }
        .card-counter {
            text-align: center; margin: 20px 0;
            font-size: 1.1em; color: #666; font-weight: bold;
        }
        .edit-mode { display: none; }
        .edit-area {
            width: 100%; min-height: 200px; padding: 15px;
            border: 2px solid #667eea; border-radius: 10px;
            font-size: 1.1em; font-family: inherit; resize: vertical;
            white-space: pre-wrap; word-wrap: break-word;
            line-height: 1.6;
        }
        .card-title-display {
            cursor: text;
            transition: background 0.2s;
            user-select: text;
            -webkit-user-select: text;
        }
        .card-title-display:hover {
            background: #e0e0e0 !important;
        }
        .edit-toolbar {
            display: flex; gap: 10px; margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .edit-toolbar .btn {
            margin: 0; padding: 8px 15px; font-size: 0.9em;
        }
        .image-preview {
            max-width: 100%; margin: 10px 0;
            border-radius: 8px; border: 2px solid #667eea;
        }
        .stats {
            background: #e3f2fd; padding: 15px;
            border-radius: 10px; margin: 10px 0; text-align: center;
        }
        .stats-item { display: inline-block; margin: 0 15px; font-size: 1.1em; }
        .stats-number { font-size: 1.5em; font-weight: bold; color: #667eea; }
        .selection-overlay {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(102,126,234,0.1);
            pointer-events: none; z-index: 1000; display: none;
        }
        /* 浮动操作按钮 */
        .floating-action-btn {
            position: fixed;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 1em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            z-index: 9999 !important;
            display: none;
            transition: all 0.3s;
            user-select: none;
            -webkit-user-select: none;
            pointer-events: auto !important;
            touch-action: manipulation !important; /* 优化触摸响应，防止双击缩放 */
            -webkit-tap-highlight-color: transparent; /* 移除触摸高亮 */
        }
        .floating-action-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .floating-action-btn.reveal-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        .notification {
            position: fixed; top: 20px; right: 20px;
            background: white; padding: 20px; border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: none; z-index: 2000; min-width: 250px;
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .notification.success { border-left: 5px solid #4caf50; }
        .notification.info { border-left: 5px solid #2196f3; }
        .notification.error { border-left: 5px solid #f44336; }
        /* 响应式设计 */
        @media (max-width: 1200px) {
            .container { max-width: 95%; }
        }
        
        @media (max-width: 768px) {
            body { 
                padding: 10px; 
                /* 移动端确保居中 */
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
            }
            html {
                /* 防止页面横向滚动 */
                overflow-x: hidden;
                width: 100%;
                max-width: 100vw;
            }
            .container { 
                margin: 0 auto; /* 保持居中 */
                border-radius: 15px;
                width: 100%;
                max-width: 100%;
            }
            .header { padding: 20px 15px; }
            .header h1 { font-size: 1.8em; margin-bottom: 5px; }
            .header p { font-size: 0.9em; }
            .content { padding: 20px 15px; }
            .btn { 
                padding: 12px 20px; 
                font-size: 0.95em; 
                margin: 8px 4px;
                width: calc(50% - 8px);
                box-sizing: border-box;
            }
            .card-content { font-size: 1em; line-height: 1.6; }
            .deck-item { 
                flex-direction: column; 
                align-items: stretch; 
                padding: 15px;
            }
            .deck-item > div { width: 100%; }
            .stats { padding: 12px; }
            .stats-item { 
                margin: 8px 10px; 
                font-size: 0.95em;
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            .stats-number { font-size: 1.3em; }
            .card-actions {
                flex-direction: column;
            }
            .card-actions .btn {
                width: 100%;
                margin: 5px 0;
            }
            .card-title-display {
                font-size: 1.1em !important;
                padding: 8px !important;
            }
            .edit-area {
                font-size: 1em;
                padding: 12px;
            }
            .card-container {
                padding: 20px 15px;
                min-height: 250px;
            }
            .file-upload-label {
                width: 100%;
                text-align: center;
                margin: 10px 0;
            }
            .import-export-buttons {
                flex-direction: column;
            }
            .import-export-buttons .file-upload-label,
            .import-export-buttons .btn {
                width: 100%;
                margin: 5px 0;
            }
            .notification {
                top: 10px;
                right: 10px;
                left: 10px;
                min-width: auto;
                max-width: calc(100% - 20px);
            }
        }
        
        @media (max-width: 480px) {
            body { padding: 5px; }
            .header { padding: 15px 10px; }
            .header h1 { font-size: 1.5em; }
            .content { padding: 15px 10px; }
            .btn { 
                padding: 10px 15px; 
                font-size: 0.9em;
                width: 100%;
                margin: 5px 0;
            }
            .stats-item { 
                margin: 5px;
                font-size: 0.85em;
            }
            .stats-number { font-size: 1.2em; }
            .card-content { font-size: 0.95em; }
            .card-title-display {
                font-size: 1em !important;
                padding: 6px !important;
            }
            .edit-toolbar {
                flex-direction: column;
            }
            .edit-toolbar .btn {
                width: 100%;
                margin: 5px 0;
            }
            .import-export-buttons {
                gap: 8px;
            }
            .import-export-buttons .file-upload-label {
                font-size: 0.95em;
                padding: 12px 20px;
            }
        }
        
        /* 横屏优化 */
        @media (max-width: 768px) and (orientation: landscape) {
            .header { padding: 15px; }
            .header h1 { font-size: 1.6em; }
            .stats {
                flex-direction: row;
                justify-content: space-around;
            }
            .stats-item {
                margin: 0 5px;
            }
        }
        
        /* 触摸设备优化 */
        @media (hover: none) and (pointer: coarse) {
            .btn {
                min-height: 44px; /* 触摸目标最小尺寸 */
            }
            .card-title-display {
                min-height: 44px;
                display: flex;
                align-items: center;
            }
            .masked {
                min-height: 24px;
                padding: 4px 10px;
            }
            .floating-action-btn {
                min-height: 44px;
                min-width: 44px;
                padding: 12px 20px;
            }
        }
        
        /* 响应式浮动按钮 */
        @media (max-width: 768px) {
            .floating-action-btn {
                font-size: 0.9em;
                padding: 10px 18px;
                border-radius: 20px;
            }
        }
        
        @media (max-width: 480px) {
            .floating-action-btn {
                font-size: 0.85em;
                padding: 8px 16px;
                max-width: calc(100vw - 40px);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
        }
    </style>
</head>
<body>
    <div class="selection-overlay" id="selectionOverlay"></div>
    <div class="notification" id="notification"></div>
    <div class="container">
        <div class="header">
            <h1>📚 Anki 学习工具</h1>
            <p>智能卡片学习系统</p>
        </div>
        <div class="content">
            <div id="mainMenu" class="main-menu">
                <div class="stats">
                    <div class="stats-item"><div>总卡包</div><div class="stats-number" id="totalDecks">0</div></div>
                    <div class="stats-item"><div>总卡片</div><div class="stats-number" id="totalCards">0</div></div>
                    <div class="stats-item"><div>待复习</div><div class="stats-number" id="totalReview">0</div></div>
                </div>
                <div class="import-export-buttons" style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: 20px;">
                    <label for="fileInput" class="file-upload-label">📁 导入 .apkg</label>
                    <label for="dataImportInput" class="file-upload-label" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">📥 导入数据</label>
                    <button class="btn btn-success" onclick="app.exportData()">📤 导出数据</button>
                    <button class="btn" style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);" onclick="app.clearAllData()">🗑️ 清空所有数据</button>
                <input type="file" id="fileInput" accept=".apkg">
                    <input type="file" id="dataImportInput" accept=".json" style="display: none;">
                </div>
                <div class="deck-list" id="deckList">
                    <p style="text-align: center; color: #999; margin-top: 30px;">请导入 .apkg 文件开始学习</p>
                </div>
            </div>
            <div id="cardListView" class="card-list-view">
                <button class="btn back-btn" onclick="app.backToMenu()">← 返回</button>
                <div class="card-counter">
                    <span id="listDeckName"></span>
                </div>
                <div class="card-list-container" id="cardListContainer">
                </div>
            </div>
            <div id="cardView" class="card-view">
                <button class="btn back-btn" onclick="app.backToCardList()">← 返回列表</button>
                <div class="card-counter">
                    <span id="currentDeckName"></span>
                    <span id="cardProgress"></span>
                </div>
                <div style="background: #e3f2fd; padding: 10px; border-radius: 8px; margin-bottom: 15px; font-size: 0.9em;">
                    💡 <strong>使用提示：</strong>选择文字后点击"遮挡"按钮 | 长按遮挡区域弹出"显示"按钮
                </div>
                <!-- 操作按钮组 - 移到卡片上方 -->
                <div class="card-actions" style="margin-bottom: 15px;">
                    <button class="btn" onclick="app.toggleEdit()">✏️ 编辑</button>
                    <button class="btn btn-success" onclick="app.nextCard()">✅ 下一张</button>
                    <button class="btn btn-secondary" onclick="app.moveToReview()">🔄 进入复习</button>
                    <button class="btn btn-warning" onclick="app.toggleAllMasks()">👁️ 显示/隐藏全部</button>
                    <button class="btn" style="background: linear-gradient(135deg, #f5576c 0%, #f093fb 100%);" onclick="app.deleteCard()">🗑️ 删除卡片</button>
                </div>
                <div class="card-container">
                    <div id="cardTitleDisplay" class="card-title-display" style="font-size: 1.3em; font-weight: bold; margin-bottom: 15px; padding: 10px; background: #f0f0f0; border-radius: 8px;"></div>
                    <div id="cardTitleEdit" class="edit-mode" style="display: none; margin-bottom: 15px;">
                        <input type="text" id="editTitle" class="edit-area" style="min-height: auto; height: 50px; font-size: 1.2em; font-weight: bold;">
                    </div>
                    <div id="cardContent" class="card-content"></div>
                    <div id="editMode" class="edit-mode">
                        <div class="edit-toolbar">
                            <label for="imageInput" class="btn btn-success" style="margin: 0;">📷 插入图片</label>
                            <input type="file" id="imageInput" accept="image/*" style="display: none;">
                            <button class="btn" onclick="app.saveEdit()">💾 保存</button>
                            <button class="btn btn-secondary" onclick="app.cancelEdit()">❌ 取消</button>
                        </div>
                        <textarea id="editArea" class="edit-area"></textarea>
                        <div id="imagePreviewContainer"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- 浮动遮挡按钮 -->
    <button id="floatingMaskBtn" class="floating-action-btn" onclick="app.maskSelection()">🔒 遮挡选中文字</button>
    <!-- 浮动取消遮挡按钮 -->
    <button id="floatingUnmaskBtn" class="floating-action-btn reveal-btn" onclick="app.unmaskElement()">❌ 取消遮挡</button>
    <script>
        const app = {
            db: null, decks: {}, currentDeck: null, currentMode: null,
            currentCardIndex: 0, isEditing: false, mediaFiles: {},
            touchStartX: 0, touchStartY: 0, isSelecting: false,
            mediaDB: null, dataDB: null,
            lastTouchX: null, lastTouchY: null,

            async init() {
                try {
                    await this.initMediaDB();
                    await this.initDataDB(); // 初始化数据存储数据库
                    await this.loadFromStorage();
                    await this.loadMediaFiles();
                    
                    // 恢复卡片备份（如果有）
                    await this.restoreCardBackup();
                    
                this.updateStats();
                this.renderDeckList();
                this.setupEventListeners();
                if (typeof marked !== 'undefined') {
                    marked.setOptions({ breaks: true, gfm: true });
                    }
                    
                    // 显示存储方式提示
                    if (this.dataDB) {
                        console.log('✅ 已启用 IndexedDB 存储，支持大量卡片数据');
                    }
                } catch (e) {
                    console.error('初始化失败:', e);
                    this.showNotification('初始化失败，部分功能可能不可用', 'error');
                }
            },
            
            // 初始化 IndexedDB 用于存储媒体文件
            async initMediaDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('ankiMediaDB', 1);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.mediaDB = request.result;
                        resolve();
                    };
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('media')) {
                            db.createObjectStore('media', { keyPath: 'filename' });
                        }
                    };
                });
            },
            
            // 初始化 IndexedDB 用于存储卡片数据（替代 localStorage）
            async initDataDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('ankiDataDB', 2);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.dataDB = request.result;
                        resolve();
                    };
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // 创建卡包存储
                        if (!db.objectStoreNames.contains('decks')) {
                            const deckStore = db.createObjectStore('decks', { keyPath: 'name' });
                            deckStore.createIndex('imported', 'imported', { unique: false });
                        }
                        
                        // 创建卡片存储（按卡包分组）
                        if (!db.objectStoreNames.contains('cards')) {
                            const cardStore = db.createObjectStore('cards', { keyPath: 'id' });
                            cardStore.createIndex('deckName', 'deckName', { unique: false });
                            cardStore.createIndex('type', 'type', { unique: false }); // 'new' 或 'review'
                        }
                    };
                });
            },
            
            // 保存媒体文件到 IndexedDB
            async saveMediaToDB(filename, blob) {
                return new Promise((resolve, reject) => {
                    if (!this.mediaDB) {
                        reject(new Error('Media DB not initialized'));
                        return;
                    }
                    const transaction = this.mediaDB.transaction(['media'], 'readwrite');
                    const store = transaction.objectStore('media');
                    const request = store.put({ filename: filename, blob: blob, timestamp: Date.now() });
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            },
            
            // 从 IndexedDB 加载媒体文件
            async loadMediaFromDB(filename) {
                return new Promise((resolve, reject) => {
                    if (!this.mediaDB) {
                        resolve(null);
                        return;
                    }
                    const transaction = this.mediaDB.transaction(['media'], 'readonly');
                    const store = transaction.objectStore('media');
                    const request = store.get(filename);
                    request.onsuccess = () => {
                        if (request.result) {
                            // 创建 blob URL
                            const url = URL.createObjectURL(request.result.blob);
                            resolve(url);
                        } else {
                            resolve(null);
                        }
                    };
                    request.onerror = () => reject(request.error);
                });
            },
            
            // 加载所有媒体文件到内存
            async loadMediaFiles() {
                if (!this.mediaDB) return;
                
                return new Promise((resolve, reject) => {
                    const transaction = this.mediaDB.transaction(['media'], 'readonly');
                    const store = transaction.objectStore('media');
                    const request = store.getAll();
                    request.onsuccess = () => {
                        request.result.forEach(item => {
                            this.mediaFiles[item.filename] = URL.createObjectURL(item.blob);
                        });
                        resolve();
                    };
                    request.onerror = () => reject(request.error);
                });
            },

            // 防止页面漂移（特别是文本选择时）
            preventPageDrift() {
                // 记录初始滚动位置和触摸起始位置
                let initialScrollX = 0;
                let initialScrollY = 0;
                let touchStartX = 0;
                let touchStartY = 0;
                let isSelecting = false;
                
                // 记录触摸起始位置
                document.addEventListener('touchstart', (e) => {
                    if (e.touches.length > 0) {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                        initialScrollX = window.scrollX || window.pageXOffset;
                        initialScrollY = window.scrollY || window.pageYOffset;
                    }
                }, { passive: true });
                
                // 防止横向滚动（但允许在可滚动元素内滚动）
                document.addEventListener('touchmove', (e) => {
                    if (e.touches.length > 0) {
                        const target = e.target;
                        // 检查是否在可滚动元素内
                        const scrollable = target.closest('.card-content, .card-container, .edit-area, .card-list-container');
                        const isScrollableElement = scrollable && (
                            scrollable.scrollHeight > scrollable.clientHeight ||
                            scrollable.scrollWidth > scrollable.clientWidth
                        );
                        
                        // 如果不在可滚动元素内，且是横向移动，阻止默认行为
                        if (!isScrollableElement) {
                            const deltaX = Math.abs(e.touches[0].clientX - touchStartX);
                            const deltaY = Math.abs(e.touches[0].clientY - touchStartY);
                            
                            // 如果横向移动明显大于纵向移动，阻止横向滚动
                            if (deltaX > deltaY && deltaX > 10) {
                                e.preventDefault();
                            }
                        }
                    }
                }, { passive: false });
                
                // 防止文本选择时页面意外滚动
                document.addEventListener('selectstart', (e) => {
                    isSelecting = true;
                    // 记录选择开始时的滚动位置
                    initialScrollX = window.scrollX || window.pageXOffset;
                    initialScrollY = window.scrollY || window.pageYOffset;
                });
                
                // 监听选择变化，防止页面漂移
                let selectionCheckTimer = null;
                document.addEventListener('selectionchange', () => {
                    if (isSelecting) {
                        // 延迟检查，避免频繁触发
                        if (selectionCheckTimer) {
                            clearTimeout(selectionCheckTimer);
                        }
                        selectionCheckTimer = setTimeout(() => {
                            const currentScrollX = window.scrollX || window.pageXOffset;
                            const currentScrollY = window.scrollY || window.pageYOffset;
                            
                            // 如果横向滚动超出合理范围（>10px），恢复位置
                            if (Math.abs(currentScrollX - initialScrollX) > 10) {
                                window.scrollTo(initialScrollX, currentScrollY);
                            }
                        }, 50);
                    }
                });
                
                // 选择结束时重置标志
                document.addEventListener('mouseup', () => {
                    isSelecting = false;
                });
                document.addEventListener('touchend', () => {
                    isSelecting = false;
                }, { passive: true });
                
                // 确保页面始终在视口内，防止横向滚动
                let scrollCheckTimer = null;
                window.addEventListener('scroll', () => {
                    // 延迟检查，避免频繁触发
                    if (scrollCheckTimer) {
                        clearTimeout(scrollCheckTimer);
                    }
                    scrollCheckTimer = setTimeout(() => {
                        const currentScrollX = window.scrollX || window.pageXOffset;
                        // 如果发生横向滚动，立即恢复
                        if (Math.abs(currentScrollX) > 1) {
                            window.scrollTo(0, window.scrollY || window.pageYOffset);
                        }
                    }, 10);
                }, { passive: true });
            },
            
            setupEventListeners() {
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    this.handleFileUpload(e.target.files[0]);
                });

                document.getElementById('dataImportInput').addEventListener('change', (e) => {
                    this.handleDataImport(e.target.files[0]);
                });

                document.getElementById('imageInput').addEventListener('change', (e) => {
                    this.handleImageUpload(e.target.files[0]);
                });
                
                // 防止文本选择时页面漂移
                this.preventPageDrift();
                
                // 页面关闭前保存遮盖状态
                window.addEventListener('beforeunload', (e) => {
                    // 在 beforeunload 中，异步操作可能无法完成
                    // 使用 sendBeacon 或同步方式保存关键数据
                    try {
                        // 先同步保存到 localStorage 作为备份
                        const cardView = document.getElementById('cardView');
                        if (cardView && cardView.style.display !== 'none' && 
                            this.currentDeck && this.currentCardIndex !== undefined && 
                            this.currentCardIndex >= 0) {
                            const deck = this.decks[this.currentDeck];
                            if (deck) {
                                const cards = this.currentMode === 'new' ? deck.newCards : deck.reviewCards;
                                if (this.currentCardIndex < cards.length) {
                                    const card = cards[this.currentCardIndex];
                                    const cardContent = document.getElementById('cardContent');
                                    if (card && cardContent && cardContent.innerHTML && cardContent.innerHTML.trim() !== '') {
                                        // 同步保存到 localStorage 作为紧急备份
                                        try {
                                            const backup = {
                                                deck: this.currentDeck,
                                                index: this.currentCardIndex,
                                                mode: this.currentMode,
                                                content: cardContent.innerHTML,
                                                front: document.getElementById('cardTitleDisplay')?.textContent || card.front
                                            };
                                            localStorage.setItem('ankiCardBackup', JSON.stringify(backup));
                                        } catch (err) {
                                            console.warn('紧急备份失败:', err);
                                        }
                                    }
                                }
                            }
                        }
                        // 尝试异步保存（可能无法完成，但不影响页面关闭）
                        this.saveCurrentCardMaskState().catch(() => {});
                    } catch (err) {
                        console.warn('beforeunload 保存失败:', err);
                    }
                });
                
                // 页面隐藏时也保存（移动端切换应用时）
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        // 页面隐藏时，有更多时间完成保存
                        this.saveCurrentCardMaskState().catch(e => console.warn('保存失败:', e));
                    } else {
                        // 页面重新可见时，恢复备份（如果有）
                        this.restoreCardBackup();
                    }
                });
                
                // 定期自动保存（每30秒保存一次，防止意外丢失）
                setInterval(() => {
                    // 只在卡片视图时自动保存
                    const cardView = document.getElementById('cardView');
                    if (cardView && cardView.style.display !== 'none') {
                        this.saveCurrentCardMaskState().catch(e => console.warn('自动保存失败:', e));
                    }
                }, 30000); // 30秒
            },

            async handleImageUpload(file) {
                if (!file) return;
                
                try {
                    // 检查文件类型
                    if (!file.type.startsWith('image/')) {
                        this.showNotification('请选择图片文件', 'error');
                        return;
                    }
                    
                    // 检查文件大小（限制为5MB）
                    if (file.size > 5 * 1024 * 1024) {
                        this.showNotification('图片文件过大，请选择小于5MB的图片', 'error');
                        return;
                    }
                    
                    this.showNotification('正在处理图片...', 'info');
                    
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const imageData = e.target.result;
                            const textarea = document.getElementById('editArea');
                            
                            if (!textarea) {
                                this.showNotification('请先进入编辑模式', 'error');
                                return;
                            }
                            
                            const cursorPos = textarea.selectionStart || 0;
                            const textBefore = textarea.value.substring(0, cursorPos);
                            const textAfter = textarea.value.substring(cursorPos);
                            
                            // 插入图片标记（使用简化的格式）
                            const imageHtml = `<img src="${imageData}" alt="图片">`;
                            textarea.value = textBefore + '\n' + imageHtml + '\n' + textAfter;
                            
                            // 移动光标到插入位置之后
                            const newCursorPos = textBefore.length + imageHtml.length + 2;
                            textarea.selectionStart = newCursorPos;
                            textarea.selectionEnd = newCursorPos;
                            textarea.focus();
                            
                            // 显示预览
                            const previewContainer = document.getElementById('imagePreviewContainer');
                            if (previewContainer) {
                                const preview = document.createElement('img');
                                preview.src = imageData;
                                preview.className = 'image-preview';
                                preview.style.maxWidth = '100%';
                                preview.style.margin = '10px 0';
                                preview.style.borderRadius = '8px';
                                previewContainer.appendChild(preview);
                            }
                            
                            // 保存图片到 IndexedDB（如果有文件名）
                            if (this.mediaDB && file.name) {
                                try {
                                    const blob = new Blob([imageData], { type: file.type });
                                    await this.saveMediaToDB(file.name, blob);
                                    console.log('图片已保存到媒体数据库:', file.name);
                                } catch (err) {
                                    console.warn('无法保存图片到媒体数据库:', err);
                                }
                            }
                            
                            this.showNotification('图片已插入', 'success');
                        } catch (error) {
                            console.error('插入图片失败:', error);
                            this.showNotification('插入图片失败', 'error');
                        }
                    };
                    
                    reader.onerror = () => {
                        this.showNotification('读取图片文件失败', 'error');
                    };
                    
                    reader.readAsDataURL(file);
                } catch (error) {
                    console.error('处理图片失败:', error);
                    this.showNotification('处理图片失败: ' + error.message, 'error');
                }
                
                // 清空文件输入，允许重复选择同一文件
                const imageInput = document.getElementById('imageInput');
                if (imageInput) {
                    imageInput.value = '';
                }
            },

            async handleFileUpload(file) {
                if (!file) return;
                this.showNotification('正在导入文件...', 'info');
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const zip = await JSZip.loadAsync(arrayBuffer);
                    
                    // 调试：列出 ZIP 中的所有文件
                    console.log('=== ZIP 文件内容 ===');
                    const fileList = Object.keys(zip.files);
                    console.log('包含的文件:', fileList);
                    fileList.forEach(filename => {
                        const file = zip.files[filename];
                        if (!file.dir) {
                            console.log(`- ${filename} (${file._data ? file._data.uncompressedSize : '?'} bytes)`);
                        }
                    });
                    
                    // 优先使用 collection.anki21（新版格式），如果不存在则使用 collection.anki2
                    const collectionFile = zip.file('collection.anki21') || zip.file('collection.anki2');
                    if (!collectionFile) throw new Error('无效的 .apkg 文件');
                    
                    console.log(`使用数据库文件: ${collectionFile.name}`);

                    const dbData = await collectionFile.async('uint8array');
                    const SQL = await initSqlJs({
                        locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
                    });
                    const db = new SQL.Database(dbData);

                    // 处理媒体文件（可选）
                    let mediaCount = 0;
                    const mediaFile = zip.file('media');
                    if (mediaFile) {
                        try {
                            // 尝试以 UTF-8 读取 media 文件
                            let mediaJson = await mediaFile.async('string');
                            
                            // 如果是空的或者开头是乱码，尝试其他编码
                            if (!mediaJson || !mediaJson.trim() || mediaJson.charCodeAt(0) > 127) {
                                console.warn('media 文件可能使用了非标准编码，尝试二进制读取');
                                const uint8Array = await mediaFile.async('uint8array');
                                const decoder = new TextDecoder('utf-8', { fatal: false });
                                mediaJson = decoder.decode(uint8Array);
                            }
                            
                            if (mediaJson && mediaJson.trim().startsWith('{')) {
                        const mediaMapping = JSON.parse(mediaJson);
                        for (const [key, filename] of Object.entries(mediaMapping)) {
                            const mediaFileData = zip.file(key);
                            if (mediaFileData) {
                                        try {
                                const blob = await mediaFileData.async('blob');
                                            // 保存到 IndexedDB，避免占用 localStorage 空间
                                            await this.saveMediaToDB(filename, blob);
                                            // 创建临时 blob URL 供当前会话使用
                                this.mediaFiles[filename] = URL.createObjectURL(blob);
                                        mediaCount++;
                                        } catch (err) {
                                            console.warn(`无法加载媒体文件 ${filename}:`, err);
                                        }
                                    }
                                }
                                console.log(`成功加载 ${mediaCount} 个媒体文件`);
                            }
                        } catch (mediaError) {
                            console.warn('无法解析媒体文件映射，跳过媒体文件:', mediaError);
                            // 继续处理，不中断整个导入过程
                        }
                    }

                    await this.parseAnkiDatabase(db, file.name);
                    this.showNotification('导入成功！', 'success');
                    this.updateStats();
                    this.renderDeckList();
                } catch (error) {
                    console.error('导入失败:', error);
                    this.showNotification('导入失败: ' + error.message, 'error');
                }
            },

            async parseAnkiDatabase(db, filename) {
                const deckName = filename.replace('.apkg', '');
                
                // 调试：查看数据库中的所有表
                console.log('=== 数据库分析 ===');
                const tables = db.exec(`SELECT name FROM sqlite_master WHERE type='table'`);
                if (tables.length > 0) {
                    console.log('可用的表:', tables[0].values.map(t => t[0]).join(', '));
                }
                
                // 检查 cards 表中的数据
                try {
                    const cardsResult = db.exec(`SELECT COUNT(*) FROM cards`);
                    if (cardsResult.length > 0) {
                        console.log('cards 表中的卡片数:', cardsResult[0].values[0][0]);
                    }
                } catch (e) {
                    console.log('无法查询 cards 表');
                }
                
                // 检查 col 表（包含集合配置）
                try {
                    const colResult = db.exec(`SELECT * FROM col`);
                    if (colResult.length > 0) {
                        console.log('col 表结构:', colResult[0].columns);
                        console.log('col 表原始数据:', colResult[0].values);
                        
                        // 尝试解析 col 表中的 JSON 数据（新版 Anki 可能在这里存储数据）
                        const colData = colResult[0].values[0];
                        console.log('col 表各字段值:', colData);
                        
                        // 检查是否有包含卡片数据的字段
                        for (let i = 0; i < colData.length; i++) {
                            const field = colData[i];
                            if (typeof field === 'string' && field.length > 100) {
                                console.log(`col 表第 ${i} 个字段 (${colResult[0].columns[i]}) 包含大量文本，可能是序列化数据`);
                                console.log('前 500 个字符:', field.substring(0, 500));
                            }
                        }
                    }
                } catch (e) {
                    console.log('无法查询 col 表:', e);
                }
                
                // 查询 notes 表
                const notes = db.exec(`SELECT id, flds, tags, mid FROM notes`);
                if (notes.length === 0) {
                    console.warn('未找到 notes 数据');
                    this.showNotification('数据库中没有找到卡片数据', 'warning');
                    return;
                }

                const cards = [];
                const rows = notes[0].values;
                console.log(`找到 ${rows.length} 条笔记`);
                
                // 检查是否是版本兼容性占位符
                let hasOnlyPlaceholder = false;
                if (rows.length === 1) {
                    const fields = rows[0][1];
                    if (fields.includes('请更新') || fields.includes('Anki') || fields.includes('版本')) {
                        hasOnlyPlaceholder = true;
                        console.warn('⚠️ 检测到版本兼容性占位符！');
                        console.warn('这个 .apkg 文件可能是用新版 Anki 导出的，需要用新版本 Anki 打开。');
                        this.showNotification(
                            '此文件格式不兼容：这是新版 Anki 导出的文件，请使用 Anki 23.10+ 版本导出为"旧版 .apkg 格式"', 
                            'error'
                        );
                    }
                }
                
                for (const row of rows) {
                    const [id, fields, tags] = row;
                    const fieldList = fields.split('\x1f');
                    
                    // 调试：输出每个字段的内容
                    console.log(`笔记 ${id}:`, fieldList);
                    
                    let content = fieldList.join('<br><br>');
                    // 注意：replaceMediaReferences 现在是异步的，但这里需要同步处理
                    // 先标记媒体引用，稍后在显示时加载
                    content = this.markMediaReferences(content);
                    
                    // 确保content不为空，如果为空则从back恢复
                    if (!content || content.trim() === '') {
                        const back = fieldList.slice(1).join('<br>') || '';
                        if (back && back.trim() !== '') {
                            content = back;
                        } else {
                            const front = fieldList[0] || '';
                            if (front && front.trim() !== '') {
                                content = front;
                            } else {
                                content = '<p>卡片内容为空</p>';
                            }
                        }
                    }
                    
                    const front = fieldList[0] || '';
                    const back = fieldList.slice(1).join('<br>') || '';
                    
                    cards.push({
                        id: `${deckName}_${id}`,
                        front: front,
                        back: back,
                        content: content, // 确保content始终有值
                        tags: tags,
                        studyCount: 0,
                        lastStudied: null,
                        maskedRanges: []
                    });
                }

                console.log(`成功解析 ${cards.length} 张卡片`);
                
                if (!hasOnlyPlaceholder) {
                this.decks[deckName] = {
                    name: deckName,
                    newCards: cards,
                    reviewCards: [],
                    imported: new Date().toISOString()
                };
                await this.saveToStorage();
                }
            },

            // 标记媒体引用（同步处理，不加载实际文件）
            markMediaReferences(content) {
                // 处理音频引用 - 保持原样，稍后加载
                // 处理图片引用 - 修复无效的 blob URL
                content = content.replace(/<img[^>]+src="([^"]+)"[^>]*>/g, (match, src) => {
                    // 如果是无效的 blob URL，标记为需要修复
                    if (src.startsWith('blob:') || src.includes('null')) {
                        // 提取可能的文件名
                        const filename = src.split('/').pop() || src;
                        // 如果媒体文件存在，直接替换
                    if (this.mediaFiles[filename]) {
                            return match.replace(src, this.mediaFiles[filename]);
                        }
                        // 否则标记为待修复（在显示时会从 IndexedDB 加载）
                        return match.replace(src, `__MEDIA__${filename}__`);
                    }
                    return match;
                });
                return content;
            },
            
            // 替换媒体引用并加载实际文件（异步）
            async replaceMediaReferences(content) {
                // 处理音频引用
                const audioRegex = /\[sound:([^\]]+)\]/g;
                const audioMatches = [];
                let match;
                while ((match = audioRegex.exec(content)) !== null) {
                    audioMatches.push({ fullMatch: match[0], filename: match[1] });
                }
                
                for (const { fullMatch, filename } of audioMatches) {
                    let url = this.mediaFiles[filename];
                    if (!url) {
                        url = await this.loadMediaFromDB(filename);
                        if (url) {
                            this.mediaFiles[filename] = url;
                        }
                    }
                    if (url) {
                        content = content.replace(fullMatch, `<audio controls onerror="this.style.display='none'"><source src="${url}"></audio>`);
                    }
                }
                
                // 处理图片引用
                const imgRegex = /<img[^>]+src="([^"]+)"[^>]*>/g;
                const imgMatches = [];
                while ((match = imgRegex.exec(content)) !== null) {
                    imgMatches.push({ fullMatch: match[0], src: match[1] });
                }
                
                for (const { fullMatch, src } of imgMatches) {
                    let url = this.mediaFiles[src];
                    let newSrc = src;
                    
                    // 检查是否是标记的待修复 URL
                    if (src.startsWith('__MEDIA__') && src.endsWith('__')) {
                        const filename = src.replace('__MEDIA__', '').replace('__', '');
                        url = await this.loadMediaFromDB(filename);
                        if (url) {
                            this.mediaFiles[filename] = url;
                            newSrc = url;
                        } else {
                            // 如果找不到，隐藏图片
                            content = content.replace(fullMatch, fullMatch.replace('<img', '<img style="display:none" onerror="this.style.display=\'none\'"'));
                            continue;
                        }
                    } else if (!url && !src.startsWith('http') && !src.startsWith('data:') && !src.startsWith('blob:')) {
                        // 尝试从 IndexedDB 加载
                        url = await this.loadMediaFromDB(src);
                        if (url) {
                            this.mediaFiles[src] = url;
                            newSrc = url;
                        }
                    } else if (src.startsWith('blob:') || src.includes('null')) {
                        // 修复无效的 blob URL
                        const filename = src.split('/').pop() || src;
                        url = await this.loadMediaFromDB(filename);
                        if (url) {
                            this.mediaFiles[filename] = url;
                            newSrc = url;
                        } else {
                            // 如果找不到，隐藏图片
                            content = content.replace(fullMatch, fullMatch.replace('<img', '<img style="display:none" onerror="this.style.display=\'none\'"'));
                            continue;
                        }
                    } else if (url) {
                        newSrc = url;
                    }
                    
                    if (newSrc !== src) {
                        content = content.replace(fullMatch, fullMatch.replace(src, newSrc));
                    }
                }
                
                return content;
            },

            renderDeckList() {
                const deckList = document.getElementById('deckList');
                const deckNames = Object.keys(this.decks);
                if (deckNames.length === 0) {
                    deckList.innerHTML = '<p style="text-align: center; color: #999; margin-top: 30px;">请导入 .apkg 文件开始学习</p>';
                    return;
                }
                deckList.innerHTML = deckNames.map(name => {
                    const deck = this.decks[name];
                    return `
                        <div class="deck-item">
                            <div class="deck-info">
                                <div class="deck-name">📚 ${name}</div>
                                <div class="deck-stats">新卡片: ${deck.newCards.length} | 待复习: ${deck.reviewCards.length}</div>
                            </div>
                            <div>
                                <button class="btn btn-success" onclick="app.startStudy('${name}', 'new')">📝 学习新卡片</button>
                                <button class="btn btn-secondary" onclick="app.startStudy('${name}', 'review')">🔄 复习</button>
                            </div>
                        </div>
                    `;
                }).join('');
            },

            startStudy(deckName, mode) {
                this.currentDeck = deckName;
                this.currentMode = mode;
                this.currentCardIndex = 0;
                const deck = this.decks[deckName];
                const cards = mode === 'new' ? deck.newCards : deck.reviewCards;
                if (cards.length === 0) {
                    this.showNotification(mode === 'new' ? '没有新卡片了！' : '没有需要复习的卡片！', 'info');
                    return;
                }
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('cardListView').style.display = 'block';
                document.getElementById('listDeckName').textContent = `${deckName} - ${mode === 'new' ? '新卡片' : '复习'} (${cards.length} 张)`;
                this.showCardList();
            },

            showCardList() {
                const deck = this.decks[this.currentDeck];
                const cards = this.currentMode === 'new' ? deck.newCards : deck.reviewCards;
                const listContainer = document.getElementById('cardListContainer');
                
                listContainer.innerHTML = cards.map((card, index) => {
                    // 获取卡片标题
                    let title = '';
                    if (card.front) {
                        title = card.front.replace(/<[^>]*>/g, '').substring(0, 50);
                    } else {
                        title = card.content.replace(/<[^>]*>/g, '').substring(0, 50);
                    }
                    title = title.trim() || `卡片 ${index + 1}`;
                    
                    // 获取预览内容
                    const preview = card.content.replace(/<[^>]*>/g, '').substring(0, 100);
                    
                    // 获取学习信息
                    const studyInfo = this.currentMode === 'review' ? 
                        `学习次数: ${card.studyCount} | 最后学习: ${card.lastStudied ? new Date(card.lastStudied).toLocaleDateString() : '未学习'}` : 
                        '新卡片';
                    
                    return `
                        <div class="card-list-item" onclick="app.showCardFromList(${index})">
                            <div class="card-list-item-title">${index + 1}. ${title}</div>
                            <div class="card-list-item-preview">${preview}${preview.length >= 100 ? '...' : ''}</div>
                            <div class="card-list-item-stats">📊 ${studyInfo}</div>
                        </div>
                    `;
                }).join('');
            },

            async showCardFromList(index) {
                this.currentCardIndex = index;
                document.getElementById('cardListView').style.display = 'none';
                document.getElementById('cardView').style.display = 'block';
                document.getElementById('currentDeckName').textContent = 
                    `${this.currentDeck} - ${this.currentMode === 'new' ? '新卡片' : '复习'}`;
                await this.showCard();
                this.initTextSelection();
            },

            async backToCardList() {
                if (this.isEditing) await this.saveEdit();
                // 保存当前卡片的遮盖状态（在切换视图前）
                await this.saveCurrentCardMaskState();
                // 清除当前卡片索引，防止保存错误的卡片
                const oldIndex = this.currentCardIndex;
                const oldDeck = this.currentDeck;
                const oldMode = this.currentMode;
                document.getElementById('cardView').style.display = 'none';
                document.getElementById('cardListView').style.display = 'block';
                // 延迟清除，确保保存完成
                setTimeout(() => {
                    // 只有在视图已切换后才清除索引
                    if (document.getElementById('cardView').style.display === 'none') {
                        // 不清除，保留以便下次快速恢复
                    }
                }, 100);
                this.showCardList();
            },

            async showCard() {
                const deck = this.decks[this.currentDeck];
                const cards = this.currentMode === 'new' ? deck.newCards : deck.reviewCards;
                if (this.currentCardIndex >= cards.length) {
                    this.showNotification('已完成所有卡片！', 'success');
                    this.backToCardList();
                    return;
                }
                const card = cards[this.currentCardIndex];
                
                // 验证卡片数据完整性
                if (!card) {
                    console.error('卡片数据不存在，索引:', this.currentCardIndex);
                    this.showNotification('卡片数据错误', 'error');
                    return;
                }
                
                // 确保卡片有内容，如果没有则尝试从原始数据恢复
                if (!card.content || card.content.trim() === '') {
                    console.warn('卡片内容为空，尝试恢复:', card.id);
                    // 尝试从 back 字段恢复
                    if (card.back) {
                        card.content = card.back;
                    } else if (card.front) {
                        card.content = card.front;
                    } else {
                        card.content = '<p>卡片内容已丢失</p>';
                        console.error('无法恢复卡片内容:', card.id);
                    }
                }
                
                document.getElementById('cardProgress').textContent = 
                    `${this.currentCardIndex + 1} / ${cards.length}` +
                    (this.currentMode === 'review' ? ` (学习次数: ${card.studyCount})` : '');
                
                // 显示标题
                const titleDisplay = document.getElementById('cardTitleDisplay');
                const titleEdit = document.getElementById('cardTitleEdit');
                titleDisplay.textContent = card.front || '无标题';
                titleDisplay.style.display = 'block';
                titleEdit.style.display = 'none';
                document.getElementById('editTitle').value = card.front || '';
                
                let content = card.content;
                
                // 确保内容不为空
                if (!content || content.trim() === '') {
                    console.error('卡片内容为空，使用默认内容');
                    content = '<p>卡片内容为空</p>';
                }
                
                // 异步加载并替换媒体引用
                content = await this.replaceMediaReferences(content);
                
                // 直接使用保存的HTML内容（包含遮挡状态）
                // 不再使用 maskedRanges，遮挡状态已经包含在HTML中
                document.getElementById('cardContent').innerHTML = content;
                
                // 将HTML转换为可读文本用于编辑（保留换行）
                const editContent = this.htmlToText(card.content);
                document.getElementById('editArea').value = editContent;
                
                this.isEditing = false;
                document.getElementById('cardContent').style.display = 'block';
                document.getElementById('editMode').style.display = 'none';
                
                // 为恢复的遮挡元素绑定双击/点击事件（支持移动端和PC端）
                setTimeout(() => {
                    document.querySelectorAll('#cardContent .masked, #cardTitleDisplay .masked').forEach(el => {
                        // 清除旧的事件监听器和标记，重新绑定（确保事件正确）
                        el.removeAttribute('data-mask-handler-bound');
                        // 移除可能存在的旧事件监听器（通过克隆节点来清除）
                        const newEl = el.cloneNode(true);
                        el.parentNode.replaceChild(newEl, el);
                        // 使用统一的处理函数，支持移动端和PC端
                        this.addMaskToggleHandler(newEl);
                        newEl.setAttribute('data-mask-handler-bound', 'true');
                    });
                    
                    // 为媒体元素添加错误处理
                    document.querySelectorAll('#cardContent img, #cardContent audio, #cardContent video').forEach(el => {
                        el.onerror = function() {
                            this.style.display = 'none';
                        };
                    });
                    
                    // 标题双击编辑（避免与文字选择冲突）
                    titleDisplay.ondblclick = () => {
                        titleDisplay.style.display = 'none';
                        titleEdit.style.display = 'block';
                        document.getElementById('editTitle').focus();
                        document.getElementById('editTitle').select();
                    };
                    
                    // 标题输入框失焦保存
                    document.getElementById('editTitle').onblur = () => {
                        const newTitle = document.getElementById('editTitle').value.trim();
                        if (newTitle && newTitle !== card.front) {
                            card.front = newTitle;
                            this.saveToStorage();
                            titleDisplay.textContent = newTitle;
                        }
                        titleDisplay.style.display = 'block';
                        titleEdit.style.display = 'none';
                    };
                    
                    // 标题输入框回车保存
                    document.getElementById('editTitle').onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            document.getElementById('editTitle').blur();
                        }
                    };
                }, 50);
                
                // 重置并初始化长按选择功能
                this.selectionInitialized = false;
                setTimeout(() => this.initTextSelection(), 100);
            },
            
            // 将HTML转换为可读文本（保留换行和格式）
            htmlToText(html) {
                if (!html) return '';
                
                // 初始化临时图片存储
                if (!this.tempImageStore) {
                    this.tempImageStore = [];
                }
                this.tempImageStore = [];
                
                let imageIndex = 0;
                // 先处理图片标签，转换为简洁的占位符
                let text = html.replace(/<img[^>]*src=["']([^"']*)["'][^>]*>/gi, (match, src) => {
                    imageIndex++;
                    
                    // 保存完整的图片标签供后续恢复使用
                    const imageId = `__IMAGE_PLACEHOLDER_${imageIndex}__`;
                    this.tempImageStore.push({
                        id: imageId,
                        fullTag: match,
                        src: src
                    });
                    
                    // 根据图片类型返回简洁的占位符
                    if (src.startsWith('data:image/')) {
                        const typeMatch = src.match(/data:image\/([^;,]+)/);
                        const imgType = typeMatch ? typeMatch[1].toUpperCase() : 'IMAGE';
                        return `\n${imageId}[图片${imageIndex}:${imgType}]${imageId}\n`;
                    } else {
                        // 提取文件名
                        const filename = src.split('/').pop().split('?')[0] || 'image';
                        return `\n${imageId}[图片${imageIndex}:${filename}]${imageId}\n`;
                    }
                });
                
                // 处理换行标签，将它们转换为换行符
                text = text
                    .replace(/<br\s*\/?>/gi, '\n')  // <br> 转换为换行
                    .replace(/<\/p>/gi, '\n\n')      // </p> 转换为双换行
                    .replace(/<\/div>/gi, '\n')     // </div> 转换为换行
                    .replace(/<\/h[1-6]>/gi, '\n\n') // 标题结束转换为双换行
                    .replace(/<hr[^>]*>/gi, '\n---\n') // 水平线
                    .replace(/<\/li>/gi, '\n')      // 列表项结束
                    .replace(/<\/ul>/gi, '\n')     // 列表结束
                    .replace(/<\/ol>/gi, '\n');     // 有序列表结束
                
                // 创建临时div来解析HTML并提取纯文本
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = text;
                
                // 获取纯文本
                text = tempDiv.innerText || tempDiv.textContent || '';
                
                // 处理HTML实体
                text = text.replace(/&nbsp;/g, ' ')
                          .replace(/&lt;/g, '<')
                          .replace(/&gt;/g, '>')
                          .replace(/&amp;/g, '&')
                          .replace(/&quot;/g, '"')
                          .replace(/&#39;/g, "'")
                          .replace(/&mdash;/g, '—')
                          .replace(/&ndash;/g, '–');
                
                // 清理多余的空白字符（但保留换行）
                text = text.replace(/[ \t]+/g, ' ')  // 多个空格/制表符压缩为一个空格
                          .replace(/[ \t]*\n[ \t]*/g, '\n')  // 清理换行前后的空格
                          .replace(/\n{4,}/g, '\n\n\n');  // 多个换行压缩为最多3个
                
                return text.trim();
            },
            
            // 将文本转换回HTML（保留换行）
            textToHtml(text) {
                if (!text) return '';
                
                // 先恢复图片占位符
                if (this.tempImageStore && this.tempImageStore.length > 0) {
                    this.tempImageStore.forEach((imgData) => {
                        const placeholderPattern = new RegExp(
                            `${this.escapeRegExp(imgData.id)}\\[图片\\d+:[^\\]]+\\]${this.escapeRegExp(imgData.id)}`,
                            'g'
                        );
                        // 将占位符替换回完整的图片标签（使用临时标记避免被转义）
                        text = text.replace(placeholderPattern, `___IMG_TAG_START___${imgData.fullTag}___IMG_TAG_END___`);
                    });
                }
                
                // 转义HTML特殊字符
                text = text.replace(/&/g, '&amp;')
                           .replace(/</g, '&lt;')
                           .replace(/>/g, '&gt;')
                           .replace(/"/g, '&quot;')
                           .replace(/'/g, '&#39;');
                
                // 恢复图片标签（不被转义）
                text = text.replace(/___IMG_TAG_START___(.+?)___IMG_TAG_END___/g, '$1');
                
                // 将换行转换为<br>
                text = text.replace(/\n\n+/g, '<br><br>')
                           .replace(/\n/g, '<br>');
                
                // 将多个空格转换为&nbsp;（但不要太多）
                text = text.replace(/  +/g, (match) => {
                    return '&nbsp;'.repeat(Math.min(match.length, 4));
                });
                
                return text;
            },
            
            // 修复无效的媒体 URL
            fixInvalidMediaUrls(content) {
                if (!content) return content;
                
                // 修复 blob:null URL 和所有无效的 blob URL
                content = content.replace(/src="(blob:null\/[^"]+|blob:[^"]+)"/g, (match, url) => {
                    // 尝试从媒体文件中查找
                    const filename = url.split('/').pop() || url;
                    // 尝试多种可能的文件名格式
                    const possibleNames = [
                        filename,
                        filename.split('?')[0], // 移除查询参数
                        decodeURIComponent(filename),
                        filename.replace(/^[a-f0-9-]+-/, '') // 移除可能的 UUID 前缀
                    ];
                    
                    for (const name of possibleNames) {
                        if (this.mediaFiles[name]) {
                            return `src="${this.mediaFiles[name]}"`;
                        }
                    }
                    
                    // 如果找不到，隐藏元素
                    return match.replace('src="', 'style="display:none" src="');
                });
                
                // 也修复音频标签中的无效 URL
                content = content.replace(/<audio[^>]*src="(blob:null\/[^"]+|blob:[^"]+)"[^>]*>/g, (match, url) => {
                    const filename = url.split('/').pop() || url;
                    const possibleNames = [
                        filename,
                        filename.split('?')[0],
                        decodeURIComponent(filename),
                        filename.replace(/^[a-f0-9-]+-/, '')
                    ];
                    
                    for (const name of possibleNames) {
                        if (this.mediaFiles[name]) {
                            return match.replace(url, this.mediaFiles[name]);
                        }
                    }
                    
                    return match.replace('<audio', '<audio style="display:none"');
                });
                
                return content;
            },

            applyMasks(content, maskedRanges) {
                if (!maskedRanges || maskedRanges.length === 0) {
                    return content;
                }
                
                // 恢复保存的遮盖状态
                maskedRanges.forEach(mask => {
                    if (mask.text && mask.html) {
                        // 使用保存的HTML来恢复遮盖元素
                        const regex = new RegExp(this.escapeRegExp(mask.text), 'g');
                        let count = 0;
                        content = content.replace(regex, (match) => {
                            count++;
                            if (count === 1) {
                                return mask.html;
                            }
                            return match;
                        });
                    }
                });
                
                return content;
            },

            escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            },

            async nextCard() {
                if (this.isEditing) await this.saveEdit();
                const deck = this.decks[this.currentDeck];
                const cards = this.currentMode === 'new' ? deck.newCards : deck.reviewCards;
                
                // 确保索引有效
                if (this.currentCardIndex >= cards.length || this.currentCardIndex < 0) {
                    this.showNotification('没有更多卡片了', 'info');
                    return;
                }
                
                const card = cards[this.currentCardIndex];
                if (!card) {
                    this.showNotification('卡片数据错误', 'error');
                    return;
                }
                
                // 保存当前卡片的遮盖状态（在切换前）
                this.saveMaskState(card);
                
                if (this.currentMode === 'review') {
                    card.studyCount++;
                    card.lastStudied = new Date().toISOString();
                }
                
                // 保存到存储
                await this.saveToStorage();
                
                // 切换到下一张
                this.currentCardIndex++;
                
                // 显示下一张卡片
                await this.showCard();
            },

            async moveToReview() {
                if (this.currentMode !== 'new') {
                    this.showNotification('此卡片已在复习队列中', 'info');
                    return;
                }
                const deck = this.decks[this.currentDeck];
                const card = deck.newCards[this.currentCardIndex];
                this.saveMaskState(card);
                deck.reviewCards.push(card);
                deck.newCards.splice(this.currentCardIndex, 1);
                await this.saveToStorage();
                this.showNotification('已加入复习队列', 'success');
                
                // 调整索引：如果删除后索引超出范围，显示上一张或下一张
                if (this.currentCardIndex >= deck.newCards.length && deck.newCards.length > 0) {
                    this.currentCardIndex = deck.newCards.length - 1;
                } else if (deck.newCards.length === 0) {
                    // 如果没有新卡片了，返回列表
                    this.backToCardList();
                    return;
                }
                
                await this.showCard();
                // showCard 中已经会绑定事件，这里不需要额外绑定
            },

            // 保存卡片的遮挡状态（保存完整HTML）
            saveMaskState(card) {
                if (!card) return;
                
                const cardContent = document.getElementById('cardContent');
                if (cardContent && cardContent.innerHTML && cardContent.innerHTML.trim() !== '') {
                    // 保存完整的HTML内容（包含遮挡状态）
                    const content = cardContent.innerHTML.trim();
                    // 确保内容不为空
                    if (content && content.length > 0) {
                        card.content = content;
                    } else {
                        // DOM内容为空，检查是否需要从back恢复
                        if (!card.content || card.content.trim() === '') {
                            if (card.back && card.back.trim() !== '') {
                                console.warn('DOM内容为空，从back字段恢复内容');
                                card.content = card.back;
                            } else if (card.front && card.front.trim() !== '') {
                                console.warn('DOM和back都为空，从front字段恢复内容');
                                card.content = card.front;
                            } else {
                                console.warn('尝试保存空内容，但无法恢复，保留原有内容');
                            }
                        } else {
                            console.warn('DOM内容为空，保留原有content');
                        }
                    }
                } else {
                    // DOM元素不存在或为空
                    if (!card.content || card.content.trim() === '') {
                        // 如果card.content也为空，尝试从back恢复
                        if (card.back && card.back.trim() !== '') {
                            console.warn('DOM为空且content为空，从back字段恢复内容');
                            card.content = card.back;
                        } else if (card.front && card.front.trim() !== '') {
                            console.warn('DOM、content和back都为空，从front字段恢复内容');
                            card.content = card.front;
                        } else {
                            console.warn('卡片内容元素不存在或为空，且无法恢复，保留原有内容');
                        }
                    } else {
                        console.warn('卡片内容元素不存在或为空，保留原有content');
                    }
                }
                
                const cardTitle = document.getElementById('cardTitleDisplay');
                if (cardTitle && cardTitle.textContent) {
                    const title = cardTitle.textContent.trim();
                    if (title) {
                        card.front = title;
                    }
                }
            },

            // 保存当前卡片的遮盖状态
            async saveCurrentCardMaskState() {
                // 检查是否真的在查看卡片视图
                const cardView = document.getElementById('cardView');
                if (!cardView || cardView.style.display === 'none') {
                    // 不在卡片视图，不需要保存
                    return;
                }
                
                // 检查是否有有效的卡片信息
                if (!this.currentDeck || this.currentCardIndex === undefined || this.currentCardIndex < 0) {
                    return;
                }
                
                const deck = this.decks[this.currentDeck];
                if (!deck) return;
                
                const cards = this.currentMode === 'new' ? deck.newCards : deck.reviewCards;
                if (this.currentCardIndex >= cards.length || cards.length === 0) {
                    return;
                }
                
                const card = cards[this.currentCardIndex];
                if (!card) return;
                
                // 检查 DOM 中是否有卡片内容
                const cardContent = document.getElementById('cardContent');
                if (!cardContent || !cardContent.innerHTML || cardContent.innerHTML.trim() === '') {
                    // DOM 中没有内容，检查card.content是否也为空
                    if (!card.content || card.content.trim() === '') {
                        // 如果card.content也为空，尝试从back恢复
                        if (card.back && card.back.trim() !== '') {
                            console.warn('DOM和content都为空，从back字段恢复内容');
                            card.content = card.back;
                            await this.saveToStorage();
                        } else if (card.front && card.front.trim() !== '') {
                            console.warn('DOM、content和back都为空，从front字段恢复内容');
                            card.content = card.front;
                            await this.saveToStorage();
                        } else {
                            console.warn('卡片内容为空且无法恢复，跳过保存');
                        }
                    } else {
                        // card.content有值，保留它（不覆盖）
                        console.warn('DOM为空但content有值，保留原有content，不保存');
                    }
                    return;
                }
                
                // 验证保存的卡片ID是否匹配（防止保存错误的卡片）
                const cardTitle = document.getElementById('cardTitleDisplay');
                const currentTitle = cardTitle ? cardTitle.textContent.trim() : '';
                const savedTitle = card.front || '';
                
                // 如果标题不匹配，可能是显示错误的卡片，不保存
                if (currentTitle && savedTitle && currentTitle !== savedTitle) {
                    console.warn('卡片标题不匹配，跳过保存。当前:', currentTitle, '保存的:', savedTitle);
                    // 不直接返回，尝试更新标题后再保存
                    card.front = currentTitle;
                }
                
                // 保存卡片状态
                this.saveMaskState(card);
                await this.saveToStorage();
            },
            
            // 恢复卡片备份（页面重新加载后）
            async restoreCardBackup() {
                try {
                    const backupStr = localStorage.getItem('ankiCardBackup');
                    if (!backupStr) return;
                    
                    const backup = JSON.parse(backupStr);
                    if (!backup || !backup.deck || backup.index === undefined) return;
                    
                    // 检查备份是否有效
                    const deck = this.decks[backup.deck];
                    if (!deck) {
                        localStorage.removeItem('ankiCardBackup');
                        return;
                    }
                    
                    const cards = backup.mode === 'new' ? deck.newCards : deck.reviewCards;
                    if (backup.index >= cards.length || backup.index < 0) {
                        localStorage.removeItem('ankiCardBackup');
                        return;
                    }
                    
                    const card = cards[backup.index];
                    if (!card) {
                        localStorage.removeItem('ankiCardBackup');
                        return;
                    }
                    
                    // 如果当前卡片内容为空或与备份不一致，恢复备份
                    if (!card.content || card.content.trim() === '' || 
                        (backup.content && backup.content.trim() !== '' && card.content !== backup.content)) {
                        console.log('恢复卡片备份:', backup.deck, backup.index);
                        card.content = backup.content;
                        if (backup.front) {
                            card.front = backup.front;
                        }
                        await this.saveToStorage();
                    }
                    
                    // 清除备份（已恢复）
                    localStorage.removeItem('ankiCardBackup');
                } catch (err) {
                    console.warn('恢复备份失败:', err);
                    localStorage.removeItem('ankiCardBackup');
                }
            },

            async toggleEdit() {
                this.isEditing = !this.isEditing;
                if (this.isEditing) {
                    document.getElementById('cardContent').style.display = 'none';
                    document.getElementById('editMode').style.display = 'block';
                    document.getElementById('imagePreviewContainer').innerHTML = '';
                    // 显示标题编辑
                    document.getElementById('cardTitleDisplay').style.display = 'none';
                    document.getElementById('cardTitleEdit').style.display = 'block';
                    
                    // 编辑模式下，重置选择初始化标记，禁用长按选择
                    this.selectionInitialized = false;
                } else {
                    await this.saveEdit();
                }
            },

            async saveEdit() {
                let newContent = document.getElementById('editArea').value;
                // 将文本转换回HTML（保留换行）
                newContent = this.textToHtml(newContent);
                // 修复内容中的无效媒体 URL
                newContent = this.fixInvalidMediaUrls(newContent);
                
                const deck = this.decks[this.currentDeck];
                const cards = this.currentMode === 'new' ? deck.newCards : deck.reviewCards;
                const card = cards[this.currentCardIndex];
                card.content = newContent;
                
                // 保存标题
                const newTitle = document.getElementById('editTitle').value.trim();
                if (newTitle) {
                    card.front = newTitle;
                }
                
                await this.saveToStorage();
                this.showNotification('保存成功', 'success');
                this.isEditing = false;
                document.getElementById('cardContent').style.display = 'block';
                document.getElementById('editMode').style.display = 'none';
                document.getElementById('imagePreviewContainer').innerHTML = '';
                await this.showCard();
                
                // 重新初始化长按选择功能
                this.selectionInitialized = false;
                setTimeout(() => this.initTextSelection(), 100);
            },

            cancelEdit() {
                this.isEditing = false;
                document.getElementById('cardContent').style.display = 'block';
                document.getElementById('editMode').style.display = 'none';
                document.getElementById('imagePreviewContainer').innerHTML = '';
                // 恢复标题显示
                document.getElementById('cardTitleDisplay').style.display = 'block';
                document.getElementById('cardTitleEdit').style.display = 'none';
                // 恢复原始内容
                const deck = this.decks[this.currentDeck];
                const cards = this.currentMode === 'new' ? deck.newCards : deck.reviewCards;
                const card = cards[this.currentCardIndex];
                document.getElementById('editArea').value = this.htmlToText(card.content);
                document.getElementById('editTitle').value = card.front || '';
                this.showNotification('已取消编辑', 'info');
                
                // 重新初始化长按选择功能
                this.selectionInitialized = false;
                setTimeout(() => this.initTextSelection(), 100);
            },
            
            // 删除当前卡片
            async deleteCard() {
                if (!confirm('确定要删除这张卡片吗？此操作无法撤销。')) {
                    return;
                }
                
                const deck = this.decks[this.currentDeck];
                const cards = this.currentMode === 'new' ? deck.newCards : deck.reviewCards;
                
                if (cards.length <= 1) {
                    this.showNotification('至少需要保留一张卡片', 'error');
                    return;
                }
                
                const cardToDelete = cards[this.currentCardIndex];
                
                // 从 IndexedDB 删除（如果使用）
                if (this.dataDB && cardToDelete.id) {
                    try {
                        const transaction = this.dataDB.transaction(['cards'], 'readwrite');
                        const cardStore = transaction.objectStore('cards');
                        await new Promise((resolve, reject) => {
                            const request = cardStore.delete(cardToDelete.id);
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        });
                    } catch (e) {
                        console.warn('从 IndexedDB 删除卡片失败:', e);
                    }
                }
                
                // 删除卡片
                cards.splice(this.currentCardIndex, 1);
                
                // 如果删除后索引超出范围，调整索引
                if (this.currentCardIndex >= cards.length) {
                    this.currentCardIndex = cards.length - 1;
                }
                
                await this.saveToStorage();
                this.showNotification('卡片已删除', 'success');
                
                // 如果删除后没有卡片了，返回列表
                if (cards.length === 0) {
                    this.backToCardList();
                } else {
                    // 显示下一张卡片
                    await this.showCard();
                }
            },

            toggleAllMasks() {
                const maskedElements = document.querySelectorAll('.masked');
                const allRevealed = Array.from(maskedElements).every(el => el.classList.contains('revealed'));
                maskedElements.forEach(el => {
                    if (allRevealed) {
                        el.classList.remove('revealed');
                    } else {
                        el.classList.add('revealed');
                    }
                });
            },

            async backToMenu() {
                if (this.isEditing) await this.saveEdit();
                // 保存当前卡片的遮盖状态（在切换视图前）
                await this.saveCurrentCardMaskState();
                document.getElementById('mainMenu').style.display = 'block';
                document.getElementById('cardView').style.display = 'none';
                document.getElementById('cardListView').style.display = 'none';
                // 延迟清除索引，确保保存完成
                setTimeout(() => {
                    // 保留索引以便快速恢复，但标记不在卡片视图
                }, 100);
                this.updateStats();
                this.renderDeckList();
            },

            initTextSelection() {
                const cardContent = document.getElementById('cardContent');
                const cardTitleDisplay = document.getElementById('cardTitleDisplay');
                const cardContainer = document.querySelector('.card-container');
                
                if (!cardContent) return;
                
                // 如果正在编辑模式，不初始化选择功能
                if (this.isEditing) {
                    this.selectionInitialized = false; // 编辑模式下重置标志
                    return;
                }
                
                // 强制重新初始化（每次显示卡片时都重新绑定事件）
                // 清除旧的标志，确保事件能重新绑定
                this.selectionInitialized = false;
                
                // 允许文本选择（包括标题和内容）
                cardContent.style.userSelect = 'text';
                cardContent.style.webkitUserSelect = 'text';
                if (cardTitleDisplay) {
                    cardTitleDisplay.style.userSelect = 'text';
                    cardTitleDisplay.style.webkitUserSelect = 'text';
                }
                
                const floatingMaskBtn = document.getElementById('floatingMaskBtn');
                const floatingUnmaskBtn = document.getElementById('floatingUnmaskBtn');
                
                if (!floatingMaskBtn || !floatingUnmaskBtn) {
                    return;
                }
                
                // 监听文本选择事件
                const handleSelectionChange = () => {
                    const selection = window.getSelection();
                    
                    if (!selection || selection.isCollapsed || selection.rangeCount === 0) {
                        floatingMaskBtn.style.display = 'none';
                        return;
                    }
                    
                    // 检查选择是否在卡片容器内（包括标题和内容）
                    const range = selection.getRangeAt(0);
                    const container = range.commonAncestorContainer;
                    
                    const isInCard = cardContainer && (
                        cardContainer.contains(container) ||
                        cardContainer === container ||
                        (container.nodeType === Node.TEXT_NODE && cardContainer.contains(container.parentNode))
                    );
                    
                    if (!isInCard) {
                        floatingMaskBtn.style.display = 'none';
                        return;
                    }
                    
                    // 显示遮挡按钮在选择区域附近
                    const rect = range.getBoundingClientRect();
                    
                    // 使用 fixed 定位，确保按钮在可见区域内
                    let btnLeft = Math.max(10, Math.min(rect.left, window.innerWidth - 190));
                    let btnTop = rect.bottom + 10;
                    
                    // 如果按钮会超出屏幕底部，显示在选择区域上方
                    if (btnTop + 50 > window.innerHeight) {
                        btnTop = rect.top - 60;
                    }
                    
                    floatingMaskBtn.style.display = 'block';
                    floatingMaskBtn.style.left = btnLeft + 'px';
                    floatingMaskBtn.style.top = btnTop + 'px';
                };
                
                // 添加选择监听
                document.addEventListener('selectionchange', handleSelectionChange);
                
                // 为遮挡区域添加长按功能（显示取消遮挡按钮）
                if (cardContainer) {
                    // 清除旧的标记，确保每次都能重新绑定（因为DOM内容可能已更新）
                    cardContainer.removeAttribute('data-longpress-bound');
                    
                    let longPressStartPos = null;
                    let longPressTriggered = false;
                    let lastClickTime = 0;
                    let touchHandled = false; // 标记触摸事件是否已处理（用于防止触摸后触发鼠标事件）
                    
                    // 长按处理函数
                    const handleLongPressStart = (e) => {
                        const target = e.target;
                        
                        // 必须是遮挡元素，且没有进行文本选择
                        if (!target.classList || !target.classList.contains('masked') || target.classList.contains('revealed')) {
                            return;
                        }
                        
                        // 检查是否是双击（通过元素的内部状态）
                        if (target._maskHandlerData && target._maskHandlerData.isDoubleClick) {
                            // 是双击，不启动长按
                            return;
                        }
                        
                        // 检测双击 - 如果距离上次点击不到400ms，说明可能是双击，不触发长按
                        const now = Date.now();
                        if (now - lastClickTime < 400) {
                            lastClickTime = now;
                            return;
                        }
                        lastClickTime = now;
                        
                        longPressTriggered = false;
                        this.longPressCompleted = false; // 重置标志
                        
                        // 记录起始位置（用于检测移动）
                        if (e.type === 'touchstart' && e.touches.length > 0) {
                            longPressStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        } else if (e.type === 'mousedown') {
                            longPressStartPos = { x: e.clientX, y: e.clientY };
                        }
                        
                        // 延迟启动长按定时器，给双击检测留出时间
                        // 先等待一段时间，确认不是双击后再启动长按
                        const longPressDelayTimer = setTimeout(() => {
                            // 再次检查是否是双击
                            if (target._maskHandlerData && target._maskHandlerData.isDoubleClick) {
                                return; // 是双击，不启动长按
                            }
                            
                            // 增加长按时间到800ms，更不容易误触
                            this.unmaskLongPressTimer = setTimeout(() => {
                                // 再次检查是否是双击（可能在定时器期间发生了双击）
                                if (target._maskHandlerData && target._maskHandlerData.isDoubleClick) {
                                    return; // 是双击，取消长按
                                }
                                
                                // 检查是否有文本选择（如果用户在选择文字，不触发）
                                const selection = window.getSelection();
                                if (selection && !selection.isCollapsed) {
                                    handleLongPressEnd();
                                    return;
                                }
                                
                                longPressTriggered = true;
                                this.longPressCompleted = false; // 初始化标志
                                
                                // 显示取消遮挡按钮
                                const rect = target.getBoundingClientRect();
                                let btnLeft = Math.max(10, Math.min(rect.left, window.innerWidth - 150));
                                let btnTop = rect.bottom + 10;
                                
                                // 如果按钮会超出屏幕底部，显示在选择区域上方
                                if (btnTop + 50 > window.innerHeight) {
                                    btnTop = rect.top - 60;
                                }
                                
                                floatingUnmaskBtn.style.display = 'block';
                                floatingUnmaskBtn.style.left = btnLeft + 'px';
                                floatingUnmaskBtn.style.top = btnTop + 'px';
                                
                                // 保存当前遮挡元素
                                this.currentUnmaskElement = target;
                                
                                // 震动反馈
                                if (navigator.vibrate) {
                                    navigator.vibrate(50);
                                }
                            }, 800); // 长按时间800ms
                        }, 400); // 延迟400ms启动长按检测，给双击留出时间
                        
                        // 保存延迟定时器，以便在 touchend 时取消
                        target._longPressDelayTimer = longPressDelayTimer;
                    };
                    
                    const handleLongPressEnd = (e) => {
                        const target = e && e.target;
                        
                        // 如果是双击，取消所有长按相关的定时器
                        if (target && target._maskHandlerData && target._maskHandlerData.isDoubleClick) {
                            // 清除延迟启动定时器
                            if (target._longPressDelayTimer) {
                                clearTimeout(target._longPressDelayTimer);
                                target._longPressDelayTimer = null;
                            }
                            // 清除长按定时器
                            if (this.unmaskLongPressTimer) {
                                clearTimeout(this.unmaskLongPressTimer);
                                this.unmaskLongPressTimer = null;
                            }
                            longPressTriggered = false;
                            this.longPressCompleted = false;
                            longPressStartPos = null;
                            return;
                        }
                        
                        // 如果长按已经触发，不要清除按钮
                        if (!longPressTriggered) {
                            // 清除延迟启动定时器
                            if (target && target._longPressDelayTimer) {
                                clearTimeout(target._longPressDelayTimer);
                                target._longPressDelayTimer = null;
                            }
                            // 清除长按定时器
                            if (this.unmaskLongPressTimer) {
                                clearTimeout(this.unmaskLongPressTimer);
                                this.unmaskLongPressTimer = null;
                            }
                        }
                        // 注意：即使长按已触发，也不清除 longPressStartPos，以便后续判断
                        // 但需要标记鼠标已松开，以便在点击事件中判断
                        if (longPressTriggered) {
                            // 长按已触发，标记鼠标已松开，但保持按钮显示
                            this.longPressCompleted = true;
                            // 在触摸设备上，阻止默认行为（如文本选择）
                            if (e && e.type === 'touchend') {
                                // 延迟一小段时间，确保按钮显示后再允许其他交互
                                setTimeout(() => {
                                    // 按钮已显示，可以正常交互
                                }, 50);
                            }
                        }
                        longPressStartPos = null;
                    };
                    
                    const handleLongPressMove = (e) => {
                        if (this.unmaskLongPressTimer && longPressStartPos) {
                            let currentX, currentY;
                            if (e.type === 'touchmove' && e.touches.length > 0) {
                                currentX = e.touches[0].clientX;
                                currentY = e.touches[0].clientY;
                                // 在触摸移动时，如果是遮挡元素，阻止默认行为（文本选择）
                                const target = e.target;
                                if (target.classList && target.classList.contains('masked') && !target.classList.contains('revealed')) {
                                    e.preventDefault();
                                }
                            } else if (e.type === 'mousemove') {
                                currentX = e.clientX;
                                currentY = e.clientY;
                            }
                            
                            // 如果移动超过5px，取消长按（从10px减少到5px，更敏感）
                            if (currentX && currentY) {
                                const distance = Math.sqrt(
                                    Math.pow(currentX - longPressStartPos.x, 2) + 
                                    Math.pow(currentY - longPressStartPos.y, 2)
                                );
                                if (distance > 5) {
                                    handleLongPressEnd();
                                }
                            }
                        }
                    };
                    
                    // 触摸事件（移动端）
                    cardContainer.addEventListener('touchstart', (e) => {
                        touchHandled = false;
                        const target = e.target;
                        // 如果是遮挡元素，但不立即阻止默认行为，给双击检测留出时间
                        // 只有在确认不是双击且需要长按时才阻止
                        if (target.classList && target.classList.contains('masked') && !target.classList.contains('revealed')) {
                            // 不立即阻止，让双击检测先工作
                            // 长按检测会在延迟后启动，如果那时确认不是双击，再考虑阻止
                        }
                        handleLongPressStart(e);
                    }, { passive: true }); // 使用 passive，避免阻止双击
                    cardContainer.addEventListener('touchend', (e) => {
                        touchHandled = true;
                        const target = e.target;
                        
                        // 如果是双击，确保取消长按
                        if (target && target._maskHandlerData && target._maskHandlerData.isDoubleClick) {
                            // 清除延迟启动定时器
                            if (target._longPressDelayTimer) {
                                clearTimeout(target._longPressDelayTimer);
                                target._longPressDelayTimer = null;
                            }
                            // 清除长按定时器
                            if (this.unmaskLongPressTimer) {
                                clearTimeout(this.unmaskLongPressTimer);
                                this.unmaskLongPressTimer = null;
                            }
                        }
                        
                        handleLongPressEnd(e);
                        // 如果长按已触发，阻止后续的 click 事件
                        if (longPressTriggered) {
                            e.preventDefault();
                        }
                    }, { passive: false });
                    cardContainer.addEventListener('touchmove', (e) => {
                        const target = e.target;
                        // 如果是遮挡元素且在长按过程中，阻止默认行为
                        if (target.classList && target.classList.contains('masked') && 
                            !target.classList.contains('revealed') && 
                            this.unmaskLongPressTimer) {
                            e.preventDefault(); // 阻止文本选择
                        }
                        handleLongPressMove(e);
                    }, { passive: false }); // 改为 false 以便阻止默认行为
                    cardContainer.addEventListener('touchcancel', handleLongPressEnd, { passive: true });
                    
                    // 鼠标事件（PC端）
                    cardContainer.addEventListener('mousedown', (e) => {
                        // 如果是触摸设备触发的鼠标事件（如触摸后触发的），忽略
                        if (touchHandled) {
                            return;
                        }
                        handleLongPressStart(e);
                    });
                    cardContainer.addEventListener('mouseup', (e) => {
                        if (touchHandled) {
                            return;
                        }
                        handleLongPressEnd(e);
                    });
                    cardContainer.addEventListener('mousemove', (e) => {
                        if (touchHandled) {
                            return;
                        }
                        handleLongPressMove(e);
                    });
                }
                
                // 点击卡片其他区域隐藏浮动按钮
                if (cardContainer) {
                    let lastTouchEndTime = 0;
                    cardContainer.addEventListener('click', (e) => {
                        // 如果点击的是浮动按钮，不要隐藏
                        if (e.target.closest('.floating-action-btn')) {
                            return;
                        }
                        
                        // 检测是否是触摸后触发的 click（移动端）
                        const now = Date.now();
                        const isTouchClick = (now - lastTouchEndTime < 500);
                        
                        // 检查是否是遮挡元素
                        const isMaskedElement = e.target.classList && e.target.classList.contains('masked') && !e.target.classList.contains('revealed');
                        
                        // 如果点击的是遮挡区域且刚刚完成了长按，保持按钮显示
                        if (isMaskedElement && this.longPressCompleted && floatingUnmaskBtn.style.display === 'block') {
                            // 长按后点击遮挡区域，保持按钮显示
                            // 如果是触摸设备上的点击，阻止默认行为
                            if (isTouchClick) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            // 保持标志，不隐藏按钮
                            return;
                        }
                        
                        // 如果点击的是遮挡区域但不是长按触发的，可能是双击
                        // 双击会通过 dblclick 事件处理，这里不隐藏按钮
                        if (isMaskedElement && !this.longPressCompleted) {
                            // 延迟检查，如果是双击，dblclick 事件会处理
                            // 这里不隐藏按钮，让双击事件自己处理
                            setTimeout(() => {
                                // 延迟后检查，如果按钮仍然显示且不是长按触发的，不隐藏
                                // 因为可能是双击触发的
                            }, 150);
                            return; // 不隐藏按钮
                        }
                        
                        // 如果点击的不是遮挡区域，正常隐藏按钮
                        // 延迟检查选择状态
                        setTimeout(() => {
                            const selection = window.getSelection();
                            if (!selection || selection.isCollapsed) {
                                floatingMaskBtn.style.display = 'none';
                            }
                        }, 100);
                        
                        // 隐藏取消遮挡按钮（只有点击非遮挡区域时才隐藏）
                        floatingUnmaskBtn.style.display = 'none';
                        // 重置标志
                        this.longPressCompleted = false;
                    });
                    
                    // 记录触摸结束时间，用于检测触摸后的 click
                    cardContainer.addEventListener('touchend', () => {
                        lastTouchEndTime = Date.now();
                    }, { passive: true });
                }
                
                // 确保浮动按钮可以被点击（支持触摸和鼠标）
                if (floatingMaskBtn) {
                    floatingMaskBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    // 触摸设备支持
                    floatingMaskBtn.addEventListener('touchend', (e) => {
                        e.stopPropagation();
                        // 触发点击事件
                        floatingMaskBtn.click();
                    }, { passive: true });
                }
                
                if (floatingUnmaskBtn) {
                    floatingUnmaskBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    // 触摸设备支持
                    floatingUnmaskBtn.addEventListener('touchend', (e) => {
                        e.stopPropagation();
                        // 触发点击事件
                        floatingUnmaskBtn.click();
                    }, { passive: true });
                }
                
                // 标记已绑定长按事件
                if (cardContainer) {
                    cardContainer.setAttribute('data-longpress-bound', 'true');
                }
                
                this.selectionInitialized = true;
            },
            
            // 取消遮挡
            unmaskElement() {
                if (!this.currentUnmaskElement) {
                    return;
                }
                
                try {
                    const maskedElement = this.currentUnmaskElement;
                    const parent = maskedElement.parentNode;
                    
                    if (!parent) {
                        return;
                    }
                    
                    // 将遮挡元素的内容提取出来，插入到原位置
                    const fragment = document.createDocumentFragment();
                    while (maskedElement.firstChild) {
                        fragment.appendChild(maskedElement.firstChild);
                    }
                    
                    // 用内容替换遮挡元素
                    parent.replaceChild(fragment, maskedElement);
                    
                    // 隐藏按钮
                    document.getElementById('floatingUnmaskBtn').style.display = 'none';
                    this.currentUnmaskElement = null;
                    this.longPressCompleted = false; // 重置标志
                    
                    // 保存状态
                    this.saveCurrentCardMaskState().catch(err => console.warn('保存失败:', err));
                    
                    this.showNotification('已取消遮挡', 'success');
                } catch (error) {
                    console.error('取消遮挡失败:', error);
                    this.showNotification('取消遮挡失败', 'error');
                }
            },
            
            // 为遮挡元素添加双击/点击切换功能（支持移动端和PC端）
            addMaskToggleHandler(element) {
                // 为每个元素创建独立的状态，避免冲突
                if (!element._maskHandlerData) {
                    element._maskHandlerData = {
                        lastClickTime: 0,
                        clickTimer: null,
                        touchStartTime: 0,
                        isDoubleClick: false
                    };
                }
                const handlerData = element._maskHandlerData;
                
                // PC端：双击切换
                element.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    // 清除可能的长按定时器（如果还在运行）
                    if (this.unmaskLongPressTimer) {
                        clearTimeout(this.unmaskLongPressTimer);
                        this.unmaskLongPressTimer = null;
                    }
                    // 清除延迟启动定时器
                    if (element._longPressDelayTimer) {
                        clearTimeout(element._longPressDelayTimer);
                        element._longPressDelayTimer = null;
                    }
                    // 如果是长按后触发的双击，清除长按标志
                    if (this.longPressCompleted) {
                        this.longPressCompleted = false;
                    }
                    handlerData.isDoubleClick = true;
                    element.classList.toggle('revealed');
                    this.saveCurrentCardMaskState().catch(err => console.warn('保存失败:', err));
                    // 清除单击定时器
                    if (handlerData.clickTimer) {
                        clearTimeout(handlerData.clickTimer);
                        handlerData.clickTimer = null;
                    }
                    handlerData.lastClickTime = 0;
                    // 延迟重置双击标志
                    setTimeout(() => {
                        handlerData.isDoubleClick = false;
                    }, 500);
                });
                
                // 移动端：触摸开始 - 记录时间，用于双击检测
                element.addEventListener('touchstart', (e) => {
                    handlerData.touchStartTime = Date.now();
                    handlerData.isDoubleClick = false;
                    
                    // 如果是已显示的遮挡元素，允许双击切换
                    // 如果是未显示的遮挡元素，延迟阻止默认行为，等待双击检测
                    if (!element.classList.contains('revealed')) {
                        // 延迟阻止，给双击检测留出时间
                        handlerData.preventDefaultTimer = setTimeout(() => {
                            // 如果300ms内没有第二次点击，才阻止默认行为（准备长按）
                            if (!handlerData.isDoubleClick && Date.now() - handlerData.touchStartTime > 300) {
                                // 此时可以安全地阻止默认行为，准备长按
                            }
                        }, 300);
                    }
                }, { passive: true }); // 先使用 passive，避免阻止双击
                
                // 移动端：双击检测（通过两次快速点击）
                element.addEventListener('touchend', (e) => {
                    // 如果长按已触发，不处理点击
                    if (this.longPressCompleted) {
                        return;
                    }
                    
                    const now = Date.now();
                    const timeSinceLastClick = now - handlerData.lastClickTime;
                    
                    // 清除延迟阻止定时器
                    if (handlerData.preventDefaultTimer) {
                        clearTimeout(handlerData.preventDefaultTimer);
                        handlerData.preventDefaultTimer = null;
                    }
                    
                    if (timeSinceLastClick < 400 && timeSinceLastClick > 0) {
                        // 双击检测：两次点击间隔小于400ms
                        handlerData.isDoubleClick = true;
                        e.preventDefault();
                        e.stopPropagation();
                        // 清除可能的长按定时器（如果还在运行）
                        if (this.unmaskLongPressTimer) {
                            clearTimeout(this.unmaskLongPressTimer);
                            this.unmaskLongPressTimer = null;
                        }
                        // 清除延迟启动定时器
                        if (element._longPressDelayTimer) {
                            clearTimeout(element._longPressDelayTimer);
                            element._longPressDelayTimer = null;
                        }
                        element.classList.toggle('revealed');
                        this.saveCurrentCardMaskState().catch(err => console.warn('保存失败:', err));
                        handlerData.lastClickTime = 0; // 重置
                        if (handlerData.clickTimer) {
                            clearTimeout(handlerData.clickTimer);
                            handlerData.clickTimer = null;
                        }
                        // 延迟重置双击标志，确保长按检测能看到它
                        setTimeout(() => {
                            handlerData.isDoubleClick = false;
                        }, 500);
                    } else {
                        // 单击：延迟处理，等待可能的第二次点击
                        handlerData.lastClickTime = now;
                        if (handlerData.clickTimer) {
                            clearTimeout(handlerData.clickTimer);
                        }
                        handlerData.clickTimer = setTimeout(() => {
                            // 单击超时，不执行任何操作
                            handlerData.clickTimer = null;
                            // 确保双击标志已重置
                            handlerData.isDoubleClick = false;
                        }, 400);
                    }
                }, { passive: false });
                
                // PC端：单击处理（双击会通过 dblclick 事件处理）
                element.addEventListener('click', (e) => {
                    // 如果长按已触发，不阻止事件传播，让父容器处理
                    if (this.longPressCompleted) {
                        return;
                    }
                    // 双击事件会通过 dblclick 处理，这里不需要额外处理
                });
            },
            
            // 遮挡选中的文字
            maskSelection() {
                const selection = window.getSelection();
                if (!selection || selection.isCollapsed) {
                    return;
                }
                
                try {
                    const range = selection.getRangeAt(0);
                    // 检查是否有实际内容
                    const selectedText = range.toString();
                    if (!selectedText || selectedText.trim().length === 0) {
                        return;
                    }
                    
                    // 创建遮挡元素
                    const span = document.createElement('span');
                    span.className = 'masked';
                    
                    // 使用 extractContents() 保留原有的 DOM 结构（包括换行、标签等）
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    
                    // 添加双击/点击切换显示/隐藏功能（支持移动端和PC端）
                    this.addMaskToggleHandler(span);
                    
                    // 插入遮挡元素
                    range.insertNode(span);
                    
                    // 规范化 DOM，合并相邻的文本节点，减少不必要的空格
                    if (span.parentNode) {
                        span.parentNode.normalize();
                    }
                    
                    // 清除选择
                    selection.removeAllRanges();
                    
                    // 隐藏按钮
                    document.getElementById('floatingMaskBtn').style.display = 'none';
                    
                    // 保存状态
                    this.saveCurrentCardMaskState().catch(err => console.warn('保存失败:', err));
                    
                    this.showNotification('已遮挡选中文字', 'success');
                } catch (error) {
                    console.error('遮挡失败:', error);
                    this.showNotification('遮挡失败', 'error');
                }
            },
            
            
            // 清空所有数据
            async clearAllData() {
                if (!confirm('⚠️ 警告：此操作将清空所有卡包数据和媒体文件，且无法恢复！\n\n确定要清空所有数据吗？')) {
                    return;
                }
                
                if (!confirm('⚠️ 最后确认：真的要清空所有数据吗？此操作无法撤销！')) {
                    return;
                }
                
                try {
                    this.showNotification('正在清空数据...', 'info');
                    
                    // 清空内存中的数据
                    this.decks = {};
                    this.mediaFiles = {};
                    
                    // 清空 localStorage
                    localStorage.removeItem('ankiStudyApp');
                    localStorage.removeItem('ankiStudyAppIndex');
                    
                    // 清空 IndexedDB
                    if (this.dataDB) {
                        const transaction = this.dataDB.transaction(['decks', 'cards'], 'readwrite');
                        await new Promise((resolve, reject) => {
                            transaction.objectStore('decks').clear();
                            transaction.objectStore('cards').clear();
                            transaction.oncomplete = () => resolve();
                            transaction.onerror = () => reject(transaction.error);
                        });
                    }
                    
                    // 清空媒体数据库
                    if (this.mediaDB) {
                        const mediaTransaction = this.mediaDB.transaction(['media'], 'readwrite');
                        await new Promise((resolve, reject) => {
                            mediaTransaction.objectStore('media').clear();
                            mediaTransaction.oncomplete = () => resolve();
                            mediaTransaction.onerror = () => reject(mediaTransaction.error);
                        });
                    }
                    
                    // 更新界面
                    this.updateStats();
                    this.renderDeckList();
                    
                    this.showNotification('✅ 所有数据已清空！', 'success');
                } catch (error) {
                    console.error('清空数据失败:', error);
                    this.showNotification('清空数据失败: ' + error.message, 'error');
                }
            },
            
            // 对指定范围应用遮盖（保留函数但简化）
            applyMaskToRange(range) {
                try {
                    // 检查范围是否有效
                    if (!range || range.collapsed) return;
                    
                    // 检查是否已经全部被遮盖
                    const walker = document.createTreeWalker(
                        range.commonAncestorContainer,
                        NodeFilter.SHOW_ELEMENT,
                        {
                            acceptNode: (node) => {
                                if (range.intersectsNode(node) && node.classList && node.classList.contains('masked')) {
                                    return NodeFilter.FILTER_ACCEPT;
                                }
                                return NodeFilter.FILTER_SKIP;
                            }
                        }
                    );
                    
                    // 如果范围内已经有遮盖元素，跳过
                    if (walker.nextNode()) {
                        return;
                    }
                    
                    // 获取范围内的文本节点
                    const textNodes = [];
                    const nodeIterator = document.createNodeIterator(
                        range.commonAncestorContainer,
                        NodeFilter.SHOW_TEXT,
                        {
                            acceptNode: (node) => {
                                if (range.intersectsNode(node) && node.textContent.trim()) {
                                    return NodeFilter.FILTER_ACCEPT;
                                }
                                return NodeFilter.FILTER_REJECT;
                            }
                        }
                    );
                    
                    let node;
                    while (node = nodeIterator.nextNode()) {
                        if (node.textContent.trim() && !node.parentNode.classList?.contains('masked')) {
                            textNodes.push(node);
                        }
                    }
                    
                    // 如果没有找到文本节点，尝试直接提取内容
                    if (textNodes.length === 0) {
                        const contents = range.extractContents();
                        const text = contents.textContent;
                        
                        if (!text || !text.trim()) return;
                        
                        // 创建遮盖元素
                        const span = document.createElement('span');
                        span.className = 'masked';
                        span.textContent = text;
                        // 添加双击/点击切换显示/隐藏功能（支持移动端和PC端）
                        this.addMaskToggleHandler(span);
                        
                        // 插入遮盖元素
                        range.insertNode(span);
                        span.parentNode.normalize();
                        return;
                    }
                    
                    // 对每个文本节点应用遮盖
                    textNodes.forEach(textNode => {
                        if (textNode.parentNode.classList?.contains('masked')) {
                            return; // 已经遮盖
                        }
                        
                        const text = textNode.textContent;
                        if (!text || !text.trim()) return;
                        
                        const span = document.createElement('span');
                        span.className = 'masked';
                        span.textContent = text;
                        // 添加双击/点击切换显示/隐藏功能（支持移动端和PC端）
                        this.addMaskToggleHandler(span);
                        
                        textNode.parentNode.replaceChild(span, textNode);
                    });
                } catch (e) {
                    console.warn('应用遮盖失败:', e);
                }
            },
            
            // 显示指定范围的遮盖
            revealRange(range) {
                try {
                    const walker = document.createTreeWalker(
                        range.commonAncestorContainer,
                        NodeFilter.SHOW_ELEMENT,
                        {
                            acceptNode: (node) => {
                                if (range.intersectsNode(node) && node.classList && node.classList.contains('masked')) {
                                    return NodeFilter.FILTER_ACCEPT;
                                }
                                return NodeFilter.FILTER_SKIP;
                            }
                        }
                    );
                    
                    let node;
                    while (node = walker.nextNode()) {
                        if (node.classList && node.classList.contains('masked')) {
                            node.classList.add('revealed');
                        }
                    }
                } catch (e) {
                    console.warn('显示遮盖失败:', e);
                }
            },

            wrapTextNode(element) {
                // 如果已经是遮盖元素，跳过
                if (element.classList && element.classList.contains('masked')) {
                    return;
                }
                
                // 跳过图片、音频、视频等媒体元素
                if (element.tagName && ['IMG', 'AUDIO', 'VIDEO', 'IFRAME', 'SVG'].includes(element.tagName)) {
                    return;
                }
                
                // 跳过媒体元素的父元素
                if (element.querySelector && (element.querySelector('img') || element.querySelector('audio') || element.querySelector('video'))) {
                    return;
                }
                
                // 只处理文本节点
                if (element.nodeType === Node.TEXT_NODE && element.textContent.trim()) {
                    // 确保父元素不是媒体相关元素
                    if (element.parentNode && element.parentNode.tagName && 
                        ['IMG', 'AUDIO', 'VIDEO', 'PICTURE'].includes(element.parentNode.tagName)) {
                        return;
                    }
                    
                    const span = document.createElement('span');
                    span.className = 'masked';
                    span.textContent = element.textContent;
                    // 添加双击/点击切换显示/隐藏功能（支持移动端和PC端）
                    this.addMaskToggleHandler(span);
                    element.parentNode.replaceChild(span, element);
                } else if (element.nodeType === Node.ELEMENT_NODE) {
                    // 对于元素节点，遮盖其直接文本内容
                    const textNodes = Array.from(element.childNodes).filter(
                        node => node.nodeType === Node.TEXT_NODE && node.textContent.trim()
                    );
                    
                    textNodes.forEach(textNode => {
                        if (!textNode.parentNode.classList || !textNode.parentNode.classList.contains('masked')) {
                            const span = document.createElement('span');
                            span.className = 'masked';
                            span.textContent = textNode.textContent;
                            // 添加双击/点击切换显示/隐藏功能（支持移动端和PC端）
                            this.addMaskToggleHandler(span);
                            textNode.parentNode.replaceChild(span, textNode);
                        }
                    });
                }
            },

            updateStats() {
                const deckCount = Object.keys(this.decks).length;
                let totalCards = 0;
                let totalReview = 0;
                for (const deck of Object.values(this.decks)) {
                    totalCards += deck.newCards.length + deck.reviewCards.length;
                    totalReview += deck.reviewCards.length;
                }
                document.getElementById('totalDecks').textContent = deckCount;
                document.getElementById('totalCards').textContent = totalCards;
                document.getElementById('totalReview').textContent = totalReview;
            },

            async saveToStorage() {
                try {
                    if (!this.dataDB) {
                        // 如果 IndexedDB 未初始化，回退到 localStorage
                        this.saveToLocalStorage();
                        return;
                    }
                    
                    // 使用 IndexedDB 存储（支持大容量，通常可存储几百MB到几GB）
                    const transaction = this.dataDB.transaction(['decks', 'cards'], 'readwrite');
                    const deckStore = transaction.objectStore('decks');
                    const cardStore = transaction.objectStore('cards');
                    
                    // 批量保存所有卡包和卡片（提高性能）
                    const savePromises = [];
                    
                    // 保存所有卡包
                    for (const [deckName, deck] of Object.entries(this.decks)) {
                        // 保存卡包元数据
                        savePromises.push(new Promise((resolve, reject) => {
                            const request = deckStore.put({
                                name: deckName,
                                imported: deck.imported || new Date().toISOString(),
                                cardCount: deck.newCards.length + deck.reviewCards.length
                            });
                            request.onsuccess = () => resolve();
                            request.onerror = () => reject(request.error);
                        }));
                        
                        // 保存新卡片
                        for (const card of deck.newCards) {
                            savePromises.push(new Promise((resolve, reject) => {
                                const cleanedCard = this.cleanCardForStorage(card);
                                cleanedCard.deckName = deckName;
                                cleanedCard.type = 'new';
                                const request = cardStore.put(cleanedCard);
                                request.onsuccess = () => resolve();
                                request.onerror = () => reject(request.error);
                            }));
                        }
                        
                        // 保存复习卡片
                        for (const card of deck.reviewCards) {
                            savePromises.push(new Promise((resolve, reject) => {
                                const cleanedCard = this.cleanCardForStorage(card);
                                cleanedCard.deckName = deckName;
                                cleanedCard.type = 'review';
                                const request = cardStore.put(cleanedCard);
                                request.onsuccess = () => resolve();
                                request.onerror = () => reject(request.error);
                            }));
                        }
                    }
                    
                    // 等待所有保存操作完成
                    await Promise.all(savePromises);
                    
                    // 同时在 localStorage 保存一个轻量级的索引（用于快速加载）
                    const deckIndex = {};
                    for (const [deckName, deck] of Object.entries(this.decks)) {
                        deckIndex[deckName] = {
                            name: deck.name,
                            imported: deck.imported,
                            newCount: deck.newCards.length,
                            reviewCount: deck.reviewCards.length
                        };
                    }
                    try {
                        localStorage.setItem('ankiStudyAppIndex', JSON.stringify(deckIndex));
                    } catch (e) {
                        // localStorage 失败不影响，数据已在 IndexedDB
                        console.warn('无法保存索引到 localStorage:', e);
                    }
                    
                } catch (e) {
                    console.error('保存到 IndexedDB 失败:', e);
                    // 回退到 localStorage
                    this.saveToLocalStorage();
                }
            },
            
            // 回退到 localStorage（兼容旧版本）
            saveToLocalStorage() {
                try {
                    const cleanedDecks = {};
                    for (const [deckName, deck] of Object.entries(this.decks)) {
                        cleanedDecks[deckName] = {
                            name: deck.name,
                            imported: deck.imported,
                            newCards: deck.newCards.map(card => this.cleanCardForStorage(card)),
                            reviewCards: deck.reviewCards.map(card => this.cleanCardForStorage(card))
                        };
                    }
                    localStorage.setItem('ankiStudyApp', JSON.stringify(cleanedDecks));
                } catch (e) {
                    if (e.name === 'QuotaExceededError') {
                        this.attemptStorageCleanup();
                    } else {
                        throw e;
                    }
                }
            },
            
            // 清理卡片数据用于存储
            cleanCardForStorage(card) {
                // 确保content不为空
                let content = card.content;
                if (!content || content.trim() === '') {
                    // 如果content为空，尝试从back恢复
                    if (card.back && card.back.trim() !== '') {
                        content = card.back;
                    } else if (card.front && card.front.trim() !== '') {
                        content = card.front;
                    } else {
                        content = '<p>卡片内容为空</p>';
                    }
                }
                
                return {
                    id: card.id,
                    front: card.front,
                    back: card.back,
                    content: this.cleanMediaFromContent(content), // 确保content始终有值
                    tags: card.tags,
                    studyCount: card.studyCount || 0,
                    lastStudied: card.lastStudied || null,
                    maskedRanges: card.maskedRanges && card.maskedRanges.length > 0 ? card.maskedRanges : undefined
                };
            },
            
            // 尝试清理存储空间
            attemptStorageCleanup() {
                try {
                    // 移除空的遮盖范围
                    for (const deck of Object.values(this.decks)) {
                        for (const card of [...deck.newCards, ...deck.reviewCards]) {
                            if (card.maskedRanges && card.maskedRanges.length === 0) {
                                delete card.maskedRanges;
                            }
                            // 清理内容中的多余空白
                            if (card.content) {
                                card.content = card.content.replace(/\s{3,}/g, ' ').trim();
                            }
                        }
                    }
                    
                    // 再次尝试保存
                    const cleanedDecks = {};
                    for (const [deckName, deck] of Object.entries(this.decks)) {
                        cleanedDecks[deckName] = {
                            name: deck.name,
                            imported: deck.imported,
                            newCards: deck.newCards.map(card => this.cleanCardForStorage(card)),
                            reviewCards: deck.reviewCards.map(card => this.cleanCardForStorage(card))
                        };
                    }
                    
                    localStorage.setItem('ankiStudyApp', JSON.stringify(cleanedDecks));
                    this.showNotification('已清理数据并保存成功', 'success');
                    
                } catch (e) {
                    // 如果还是失败，提示用户导出数据
                    const totalCards = Object.values(this.decks).reduce((sum, deck) => 
                        sum + deck.newCards.length + deck.reviewCards.length, 0);
                    
                    const message = 
                        `存储空间不足！\n\n` +
                        `当前有 ${totalCards} 张卡片，数据量过大。\n\n` +
                        `建议：\n` +
                        `1. 导出数据备份\n` +
                        `2. 删除一些不需要的卡片\n` +
                        `3. 清除浏览器缓存\n\n` +
                        `是否现在导出数据？`;
                    
                    if (confirm(message)) {
                        this.exportData();
                    } else {
                        this.showNotification('存储失败，请清理数据或导出备份', 'error');
                    }
                }
            },
            
            // 清理内容中的 base64 数据 URL，只保留文件名引用
            cleanMediaFromContent(content) {
                if (!content) return content;
                
                // 移除 data: URL（base64 图片数据很大）
                content = content.replace(/src="data:[^"]+"/g, 'src="__MEDIA_REF__"');
                
                // 移除无效的 blob URL
                content = content.replace(/src="blob:null\/[^"]+"/g, 'src="__MEDIA_REF__"');
                content = content.replace(/src="blob:[^"]+"/g, (match) => {
                    // 尝试提取文件名
                    const filename = match.match(/blob:[^"]+\/([^"]+)/);
                    return filename ? `src="__MEDIA__${filename[1]}__"` : 'src="__MEDIA_REF__"';
                });
                
                // 压缩多余的空白字符（但保留换行）
                content = content.replace(/[ \t]{2,}/g, ' '); // 多个空格/制表符压缩为一个
                content = content.replace(/\n{4,}/g, '\n\n\n'); // 多个换行压缩为最多3个
                
                return content;
            },

            async loadFromStorage() {
                // 优先从 IndexedDB 加载
                if (this.dataDB) {
                    try {
                        await this.loadFromIndexedDB();
                        return;
                    } catch (e) {
                        console.warn('从 IndexedDB 加载失败，尝试从 localStorage 加载:', e);
                    }
                }
                
                // 回退到 localStorage
                const data = localStorage.getItem('ankiStudyApp');
                if (data) {
                    try {
                        const parsed = JSON.parse(data);
                        // 兼容旧版本格式
                        if (parsed.decks) {
                            this.decks = parsed.decks;
                        } else if (typeof parsed === 'object') {
                            this.decks = parsed;
                        } else {
                            this.decks = {};
                        }
                        
                        // 修复空内容：如果 content 为空，从 back 或 front 恢复
                        for (const deck of Object.values(this.decks)) {
                            for (const card of [...deck.newCards, ...deck.reviewCards]) {
                                if (!card.content || card.content.trim() === '') {
                                    if (card.back && card.back.trim() !== '') {
                                        console.log('修复空内容：从back恢复', card.id);
                                        card.content = card.back;
                                    } else if (card.front && card.front.trim() !== '') {
                                        console.log('修复空内容：从front恢复', card.id);
                                        card.content = card.front;
                                    } else {
                                        console.warn('无法恢复空内容', card.id);
                                        card.content = '<p>卡片内容已丢失</p>';
                                    }
                                }
                            }
                        }
                        
                        // 迁移到 IndexedDB（如果有修复，会自动保存）
                        await this.migrateToIndexedDB();
                    } catch (e) {
                        console.error('加载数据失败:', e);
                        this.showNotification('加载数据失败，请重新导入', 'error');
                        this.decks = {};
                    }
                }
            },
            
            // 从 IndexedDB 加载数据
            async loadFromIndexedDB() {
                if (!this.dataDB) return;
                
                const transaction = this.dataDB.transaction(['decks', 'cards'], 'readonly');
                const deckStore = transaction.objectStore('decks');
                const cardStore = transaction.objectStore('cards');
                
                // 获取所有卡包
                const decks = await new Promise((resolve, reject) => {
                    const request = deckStore.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                this.decks = {};
                
                // 为每个卡包加载卡片
                for (const deckInfo of decks) {
                    const deckName = deckInfo.name;
                    
                    // 获取该卡包的所有卡片
                    const allCards = await new Promise((resolve, reject) => {
                        const index = cardStore.index('deckName');
                        const request = index.getAll(deckName);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    // 修复空内容：如果 content 为空，从 back 或 front 恢复
                    for (const card of allCards) {
                        if (!card.content || card.content.trim() === '') {
                            if (card.back && card.back.trim() !== '') {
                                console.log('修复空内容：从back恢复', card.id);
                                card.content = card.back;
                            } else if (card.front && card.front.trim() !== '') {
                                console.log('修复空内容：从front恢复', card.id);
                                card.content = card.front;
                            } else {
                                console.warn('无法恢复空内容', card.id);
                                card.content = '<p>卡片内容已丢失</p>';
                            }
                        }
                    }
                    
                    // 分离新卡片和复习卡片
                    const newCards = allCards.filter(c => c.type === 'new');
                    const reviewCards = allCards.filter(c => c.type === 'review');
                    
                    this.decks[deckName] = {
                        name: deckName,
                        imported: deckInfo.imported,
                        newCards: newCards,
                        reviewCards: reviewCards
                    };
                }
                
                // 检查是否有修复（任何从back或front恢复的内容）
                let hasFixed = false;
                for (const deck of Object.values(this.decks)) {
                    for (const card of [...deck.newCards, ...deck.reviewCards]) {
                        // 检查是否是从back或front恢复的（通过比较content和back/front）
                        if (card.content && card.back && card.content === card.back && 
                            (!card.content.includes('卡片内容已丢失'))) {
                            hasFixed = true;
                            break;
                        } else if (card.content && card.front && card.content === card.front && 
                            (!card.content.includes('卡片内容已丢失'))) {
                            hasFixed = true;
                            break;
                        }
                    }
                    if (hasFixed) break;
                }
                
                if (hasFixed) {
                    console.log('检测到内容修复，保存到存储');
                    await this.saveToStorage();
                }
            },
            
            // 迁移 localStorage 数据到 IndexedDB
            async migrateToIndexedDB() {
                if (!this.dataDB) return;
                
                try {
                    await this.saveToStorage();
                    console.log('数据已迁移到 IndexedDB');
                } catch (e) {
                    console.warn('迁移到 IndexedDB 失败:', e);
                }
            },

            showNotification(message, type = 'info') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = `notification ${type}`;
                notification.style.display = 'block';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            },
            
            // 导出数据（包括卡包和学习进度）
            async exportData() {
                try {
                    this.showNotification('正在准备导出数据...', 'info');
                    
                    // 保存当前状态
                    await this.saveCurrentCardMaskState();
                    
                    // 准备导出数据
                    const exportData = {
                        version: '2.0',
                        exportDate: new Date().toISOString(),
                        appName: 'Anki Study Tool',
                        decks: {},
                        mediaFiles: [] // 媒体文件列表（包含元数据）
                    };
                    
                    // 深拷贝卡包数据，确保导出的是最新状态
                    for (const [deckName, deck] of Object.entries(this.decks)) {
                        exportData.decks[deckName] = {
                            name: deck.name,
                            imported: deck.imported,
                            newCards: JSON.parse(JSON.stringify(deck.newCards)),
                            reviewCards: JSON.parse(JSON.stringify(deck.reviewCards))
                        };
                    }
                    
                    // 从 IndexedDB 获取媒体文件列表
                    if (this.mediaDB) {
                        const transaction = this.mediaDB.transaction(['media'], 'readonly');
                        const store = transaction.objectStore('media');
                        const request = store.getAll();
                        
                        await new Promise((resolve, reject) => {
                            request.onsuccess = () => {
                                exportData.mediaFiles = request.result.map(item => ({
                                    filename: item.filename,
                                    timestamp: item.timestamp,
                                    size: item.blob.size,
                                    type: item.blob.type
                                }));
                                resolve();
                            };
                            request.onerror = () => {
                                console.warn('无法获取媒体文件列表:', request.error);
                                resolve(); // 即使失败也继续导出
                            };
                        });
                    }
                    
                    // 计算统计信息
                    let totalCards = 0;
                    let totalReview = 0;
                    for (const deck of Object.values(exportData.decks)) {
                        totalCards += deck.newCards.length + deck.reviewCards.length;
                        totalReview += deck.reviewCards.length;
                    }
                    
                    exportData.statistics = {
                        totalDecks: Object.keys(exportData.decks).length,
                        totalCards: totalCards,
                        totalReview: totalReview
                    };
                    
                    // 转换为JSON字符串
                    const jsonString = JSON.stringify(exportData, null, 2);
                    
                    // 检查文件大小
                    const sizeInMB = new Blob([jsonString]).size / (1024 * 1024);
                    if (sizeInMB > 50) {
                        if (!confirm(`导出文件大小约为 ${sizeInMB.toFixed(2)} MB，可能较大。是否继续？`)) {
                            return;
                        }
                    }
                    
                    // 创建Blob并下载
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const dateStr = new Date().toISOString().split('T')[0];
                    a.download = `anki-study-backup-${dateStr}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    this.showNotification(
                        `导出成功！包含 ${exportData.statistics.totalDecks} 个卡包，${exportData.statistics.totalCards} 张卡片`,
                        'success'
                    );
                } catch (error) {
                    console.error('导出失败:', error);
                    this.showNotification('导出失败: ' + error.message, 'error');
                }
            },
            
            // 导入数据（包括卡包和学习进度）
            async handleDataImport(file) {
                if (!file) return;
                
                this.showNotification('正在导入数据...', 'info');
                
                try {
                    // 检查文件大小
                    const sizeInMB = file.size / (1024 * 1024);
                    if (sizeInMB > 100) {
                        if (!confirm(`导入文件大小约为 ${sizeInMB.toFixed(2)} MB，可能较大。是否继续？`)) {
                            return;
                        }
                    }
                    
                    const text = await file.text();
                    const importData = JSON.parse(text);
                    
                    // 验证数据格式
                    if (!importData.decks || typeof importData.decks !== 'object') {
                        throw new Error('无效的数据格式：缺少卡包数据');
                    }
                    
                    // 检查版本兼容性
                    if (importData.version && parseFloat(importData.version) < 1.0) {
                        if (!confirm('检测到旧版本数据格式，可能不完全兼容。是否继续导入？')) {
                            return;
                        }
                    }
                    
                    // 统计导入数据
                    let importStats = {
                        totalDecks: Object.keys(importData.decks).length,
                        totalCards: 0,
                        totalReview: 0
                    };
                    
                    for (const deck of Object.values(importData.decks)) {
                        importStats.totalCards += (deck.newCards?.length || 0) + (deck.reviewCards?.length || 0);
                        importStats.totalReview += deck.reviewCards?.length || 0;
                    }
                    
                    // 确认是否覆盖现有数据
                    const hasExistingData = Object.keys(this.decks).length > 0;
                    let shouldMerge = false;
                    
                    if (hasExistingData) {
                        const existingStats = {
                            totalDecks: Object.keys(this.decks).length,
                            totalCards: 0,
                            totalReview: 0
                        };
                        
                        for (const deck of Object.values(this.decks)) {
                            existingStats.totalCards += deck.newCards.length + deck.reviewCards.length;
                            existingStats.totalReview += deck.reviewCards.length;
                        }
                        
                        const message = 
                            `检测到已有数据：\n` +
                            `现有：${existingStats.totalDecks} 个卡包，${existingStats.totalCards} 张卡片\n` +
                            `导入：${importStats.totalDecks} 个卡包，${importStats.totalCards} 张卡片\n\n` +
                            `点击"确定"合并数据（保留现有数据，只添加新数据）\n` +
                            `点击"取消"完全替换（删除所有现有数据）`;
                        
                        shouldMerge = confirm(message);
                    }
                    
                    if (shouldMerge) {
                        // 合并数据：保留现有数据，添加新数据
                        let addedDecks = 0;
                        let addedCards = 0;
                        let skippedCards = 0;
                        
                        for (const [deckName, deck] of Object.entries(importData.decks)) {
                            if (this.decks[deckName]) {
                                // 如果卡包已存在，合并卡片
                                const existingDeck = this.decks[deckName];
                                
                                // 合并新卡片（避免重复）
                                const existingIds = new Set([
                                    ...existingDeck.newCards.map(c => c.id),
                                    ...existingDeck.reviewCards.map(c => c.id)
                                ]);
                                
                                const beforeNew = existingDeck.newCards.length;
                                const beforeReview = existingDeck.reviewCards.length;
                                
                                deck.newCards?.forEach(card => {
                                    if (!existingIds.has(card.id)) {
                                        existingDeck.newCards.push(card);
                                        addedCards++;
                                    } else {
                                        skippedCards++;
                                    }
                                });
                                
                                deck.reviewCards?.forEach(card => {
                                    if (!existingIds.has(card.id)) {
                                        existingDeck.reviewCards.push(card);
                                        addedCards++;
                                    } else {
                                        skippedCards++;
                                    }
                                });
                            } else {
                                // 新卡包，直接添加
                                this.decks[deckName] = {
                                    name: deck.name || deckName,
                                    imported: deck.imported || new Date().toISOString(),
                                    newCards: deck.newCards || [],
                                    reviewCards: deck.reviewCards || []
                                };
                                addedDecks++;
                                addedCards += (deck.newCards?.length || 0) + (deck.reviewCards?.length || 0);
                            }
                        }
                        
                        this.showNotification(
                            `合并成功！新增 ${addedDecks} 个卡包，${addedCards} 张卡片（跳过 ${skippedCards} 张重复卡片）`,
                            'success'
                        );
                    } else {
                        // 完全替换
                        this.decks = {};
                        for (const [deckName, deck] of Object.entries(importData.decks)) {
                            this.decks[deckName] = {
                                name: deck.name || deckName,
                                imported: deck.imported || new Date().toISOString(),
                                newCards: deck.newCards || [],
                                reviewCards: deck.reviewCards || []
                            };
                        }
                        this.showNotification(
                            `导入成功！${importStats.totalDecks} 个卡包，${importStats.totalCards} 张卡片`,
                            'success'
                        );
                    }
                    
                    // 保存到存储
                    await this.saveToStorage();
                    
                    // 更新界面
                    this.updateStats();
                    this.renderDeckList();
                    
                    // 如果导入的数据包含媒体文件信息，提示用户
                    if (importData.mediaFiles && importData.mediaFiles.length > 0) {
                        setTimeout(() => {
                            this.showNotification(
                                `提示：已导入 ${importData.mediaFiles.length} 个媒体文件信息。媒体文件需要重新从 .apkg 文件导入。`,
                                'info'
                            );
                        }, 2000);
                    }
                    
                } catch (error) {
                    console.error('导入失败:', error);
                    if (error instanceof SyntaxError) {
                        this.showNotification('导入失败：文件格式错误，请确保是有效的 JSON 文件', 'error');
                    } else {
                        this.showNotification('导入失败: ' + error.message, 'error');
                    }
                }
            }
        };

        window.addEventListener('DOMContentLoaded', () => {
            app.init();
        });
    </script>
</body>
</html>
